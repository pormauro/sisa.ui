Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: AuthContext.tsx
Content:
import React, { createContext, useState, useEffect, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as SecureStore from 'expo-secure-store';
import { Alert } from 'react-native';
import { BASE_URL } from '@/config/Index';

interface AuthContextProps {
  userId: string | null;
  isLoading: boolean;
  username: string | null;
  email: string | null;
  isOffline: boolean;
  token: string | null;
  login: (loginUsername: string, loginPassword: string) => Promise<void>;
  logout: () => Promise<void>;
  checkConnection: () => Promise<void>;
}

export const AuthContext = createContext<AuthContextProps>({
  userId: null,
  isLoading: true,
  username: null,
  email: null,
  isOffline: false,
  token: null,
  login: async () => {},
  logout: async () => {},
  checkConnection: async () => {},
});

// ConfiguraciÃ³n de tiempos y reintentos (ajustables)
const MAX_RETRY = 3;
const RETRY_DELAY = 10000; // 10 segundos de espera para reintentar
const TIMEOUT_DURATION = 10000; // 10 segundos de timeout en las peticiones
const PROFILE_CHECK_INTERVAL = 2 * 60 * 1000; // 2 minutos para revisar el perfil

// FunciÃ³n auxiliar para hacer fetch con timeout
const fetchWithTimeout = async (resource: string, options: any = {}) => {
  const { timeout = TIMEOUT_DURATION, ...rest } = options;
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(resource, { ...rest, signal: controller.signal });
    return response;
  } finally {
    clearTimeout(id);
  }
};

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [userId, setUserId] = useState<string | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [username, setUsername] = useState<string | null>(null);
  const [email, setEmail] = useState<string | null>(null);
  const [password, setPassword] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [isOffline, setIsOffline] = useState<boolean>(false);

  const saveItem = async (key: string, value: string) => {
    try {
      await SecureStore.setItemAsync(key, value);
    } catch (error) {
      console.error(`Error saving ${key}:`, error);
    }
  };

  const getItem = async (key: string): Promise<string | null> => {
    try {
      return await SecureStore.getItemAsync(key);
    } catch (error) {
      console.error(`Error getting ${key}:`, error);
      return null;
    }
  };

  const removeItem = async (key: string) => {
    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error(`Error deleting ${key}:`, error);
    }
  };

  // FunciÃ³n auxiliar para limpiar las credenciales (usada en logout y login fallido)
  const clearCredentials = async () => {
    await removeItem('token');
    await removeItem('user_id');
    await removeItem('username');
    await removeItem('password');
    await removeItem('token_expiration');
    await removeItem('email');
    setToken(null);
    setUserId(null);
    setUsername(null);
    setPassword(null);
    setEmail(null);
    setIsOffline(false);
  };

  const performLogin = useCallback(
    async (loginUsername: string, loginPassword: string, retryCount = 0) => {
      try {
        // PeticiÃ³n de login con timeout
        const response = await fetchWithTimeout(`${BASE_URL}/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: loginUsername, password: loginPassword }),
          timeout: TIMEOUT_DURATION,
        });

        if (response.ok) {
          const authHeader = response.headers.get('Authorization');
          const newToken =
            authHeader && authHeader.startsWith('Bearer ')
              ? authHeader.split(' ')[1]
              : null;
          // Si el token estÃ¡ vacÃ­o, se considera que las credenciales fallaron
          if (!newToken) {
            await clearCredentials();
            throw new Error('Credenciales invÃ¡lidas, por favor intente nuevamente.');
          }

          // Obtenemos el perfil para extraer el email y demÃ¡s datos
          const profileResponse = await fetchWithTimeout(`${BASE_URL}/profile`, {
            method: 'GET',
            headers: {
              Authorization: `Bearer ${newToken}`,
              'Content-Type': 'application/json',
            },
            timeout: TIMEOUT_DURATION,
          });

          if (!profileResponse.ok) {
            throw new Error('No se pudo obtener el perfil del usuario');
          }

          const profileData = await profileResponse.json();
          const { id, email: userEmail } = profileData.user;
          const nowInArgentina = new Date(new Date().toLocaleString("en-US", { timeZone: "America/Argentina/Buenos_Aires" }));
          const expirationTime = (nowInArgentina.getTime() + 3600 * 1000).toString();

          await saveItem('token', newToken);
          await saveItem('user_id', id.toString());
          await saveItem('username', loginUsername);
          await saveItem('password', loginPassword);
          await saveItem('token_expiration', expirationTime);
          await saveItem('email', userEmail);

          setToken(newToken);
          setUserId(id.toString());
          setUsername(loginUsername);
          setPassword(loginPassword);
          setEmail(userEmail);

          // ConexiÃ³n exitosa, marcar como online
          setIsOffline(false);
        } else {
          const errorResult = await response.json();
          throw new Error(errorResult.error || 'Error en el login');
        }
      } catch (error: any) {
        // Si es un timeout y aÃºn no se excede el nÃºmero de reintentos, reintenta despuÃ©s de un retardo
        if (
          (error.name === 'AbortError' || error.message.toLowerCase().includes('timeout')) &&
          retryCount < MAX_RETRY
        ) {
          setTimeout(() => {
            performLogin(loginUsername, loginPassword, retryCount + 1);
          }, RETRY_DELAY);
          return;
        }
        // Si es un error de red, marcar como offline
        if (error.message && error.message.toLowerCase().includes('network')) {
          setIsOffline(true);
        } else {
          setIsOffline(false);
        }
        Alert.alert('Error de Login', error.message);
      }
    },
    []
  );

  const login = useCallback(
    async (loginUsername: string, loginPassword: string) => {
      await performLogin(loginUsername, loginPassword);
    },
    [performLogin]
  );

  const checkTokenValidity = useCallback(async (): Promise<boolean> => {
    const expiration = await getItem('token_expiration');
    if (!expiration) return false;
    const expirationTime = parseInt(expiration, 10);
    const now = new Date().getTime();
    return now < expirationTime;
  }, []);

  const autoLogin = useCallback(async () => {
    const storedUsername = await getItem('username');
    const storedPassword = await getItem('password');
    const storedToken = await getItem('token');
    const storedEmail = await getItem('email');
    const tokenValid = await checkTokenValidity();

    if (storedUsername && storedPassword && storedToken && tokenValid) {
      const storedUserId = await getItem('user_id');
      setToken(storedToken);
      setUserId(storedUserId);
      setUsername(storedUsername);
      setPassword(storedPassword);
      setEmail(storedEmail);
    } else if (storedUsername && storedPassword) {
      await performLogin(storedUsername, storedPassword);
    }
    setIsLoading(false);
  }, [checkTokenValidity, performLogin]);

  const logout = useCallback(async () => {
    await clearCredentials();
  }, []);

  const checkConnection = useCallback(async () => {
    if (!token) {
      setIsOffline(true);
      return;
    }
    try {
      const response = await fetchWithTimeout(`${BASE_URL}/profile`, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        timeout: TIMEOUT_DURATION,
      });
      
      // Si recibimos 401, el token es invÃ¡lido o ha expirado, se reintenta el login
      if (response.status === 401) {
        if (username && password) {
          await performLogin(username, password);
        } else {
          setIsOffline(true);
        }
        return;
      }

      if (!response.ok) {
        setIsOffline(true);
      } else {
        setIsOffline(false);
      }
    } catch (error) {
      setIsOffline(true);
    }
  }, [token, username, password, performLogin]);

  useEffect(() => {
    autoLogin();
  }, [autoLogin]);

  // Chequeo periÃ³dico de la validez del token cada 5 minutos
  useEffect(() => {
    const interval = setInterval(async () => {
      const valid = await checkTokenValidity();
      if (!valid && username && password) {
        await performLogin(username, password);
      }
    }, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [checkTokenValidity, performLogin, username, password]);

  // Chequeo periÃ³dico del perfil cada 2 minutos para confirmar que sigue logueado
  useEffect(() => {
    const interval = setInterval(async () => {
      await checkConnection();
      // Si no estÃ¡ online y hay credenciales almacenadas, se reintenta el login automÃ¡ticamente
      if (isOffline && username && password) {
        await performLogin(username, password);
      }
    }, PROFILE_CHECK_INTERVAL);
    return () => clearInterval(interval);
  }, [checkConnection, isOffline, username, password, performLogin]);

  return (
    <AuthContext.Provider
      value={{
        userId,
        isLoading,
        username,
        email,
        isOffline,
        token,
        login,
        logout,
        checkConnection,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export default AuthProvider;

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: CashBoxesContext.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/contexts/CashBoxesContext.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface CashBox {
  id: number;
  name: string;
  image_file_id: string | null;
  user_id: number;
  // Puedes agregar mÃ¡s campos si los requiere tu API
}

interface CashBoxesContextType {
  cashBoxes: CashBox[];
  loadCashBoxes: () => void;
  addCashBox: (cashBox: Omit<CashBox, 'id' | 'user_id'>) => Promise<CashBox | null>;
  updateCashBox: (id: number, cashBox: Omit<CashBox, 'id' | 'user_id'>) => Promise<boolean>;
  deleteCashBox: (id: number) => Promise<boolean>;
  listCashBoxHistory: (id: number) => Promise<any[]>; // Opcional, para historial
}

export const CashBoxesContext = createContext<CashBoxesContextType>({
  cashBoxes: [],
  loadCashBoxes: () => {},
  addCashBox: async () => null,
  updateCashBox: async () => false,
  deleteCashBox: async () => false,
  listCashBoxHistory: async () => []
});

export const CashBoxesProvider = ({ children }: { children: ReactNode }) => {
  const [cashBoxes, setCashBoxes] = useState<CashBox[]>([]);
  const { token } = useContext(AuthContext);

  const loadCashBoxes = async () => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.cash_boxes) {
        setCashBoxes(data.cash_boxes);
      }
    } catch (error) {
      console.error("Error loading cash boxes:", error);
    }
  };

  const addCashBox = async (cashBoxData: Omit<CashBox, 'id' | 'user_id'>): Promise<CashBox | null> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(cashBoxData)
      });
      const data = await response.json();
      if (data.cash_box_id) {
        const newCashBox: CashBox = { id: parseInt(data.cash_box_id, 10), user_id: 0, ...cashBoxData };
        setCashBoxes(prev => [...prev, newCashBox]);
        return newCashBox;
      }
    } catch (error) {
      console.error("Error adding cash box:", error);
    }
    return null;
  };

  const updateCashBox = async (id: number, cashBoxData: Omit<CashBox, 'id' | 'user_id'>): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(cashBoxData)
      });
      const data = await response.json();
      if (data.message === 'Cash box updated successfully') {
        setCashBoxes(prev =>
          prev.map(cb => (cb.id === id ? { ...cb, ...cashBoxData } : cb))
        );
        return true;
      }
    } catch (error) {
      console.error("Error updating cash box:", error);
    }
    return false;
  };

  const deleteCashBox = async (id: number): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.message === 'Cash box deleted successfully') {
        setCashBoxes(prev => prev.filter(cb => cb.id !== id));
        return true;
      }
    } catch (error) {
      console.error("Error deleting cash box:", error);
    }
    return false;
  };

  const listCashBoxHistory = async (id: number): Promise<any[]> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes/${id}/history`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.history) {
        return data.history;
      }
    } catch (error) {
      console.error("Error listing cash box history:", error);
    }
    return [];
  };

  useEffect(() => {
    if (token) {
      loadCashBoxes();
    }
  }, [token]);

  return (
    <CashBoxesContext.Provider value={{ cashBoxes, loadCashBoxes, addCashBox, updateCashBox, deleteCashBox, listCashBoxHistory }}>
      {children}
    </CashBoxesContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: ClientsContext.tsx
Content:
// /contexts/ClientsContext.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface Client {
  id: number;
  business_name: string;
  tax_id: string;
  email: string;
  brand_file_id: string | null;
  phone: string;
  address: string;
}

interface ClientsContextValue {
  clients: Client[];
  loadClients: () => void;
  addClient: (client: Omit<Client, 'id'>) => Promise<Client | null>;
  updateClient: (id: number, client: Omit<Client, 'id'>) => Promise<boolean>;
  deleteClient: (id: number) => Promise<boolean>;
}

export const ClientsContext = createContext<ClientsContextValue>({
  clients: [],
  loadClients: () => {},
  addClient: async () => null,
  updateClient: async () => false,
  deleteClient: async () => false,
});

export const ClientsProvider = ({ children }: { children: ReactNode }) => {
  const [clients, setClients] = useState<Client[]>([]);
  const { token } = useContext(AuthContext);

  const loadClients = async () => {
    
    try {
      const response = await fetch(`${BASE_URL}/clients`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.clients) {
        setClients(data.clients);
      }
    } catch (error) {
      console.error("Error loading clients:", error);
    }
  };

  const addClient = async (clientData: Omit<Client, 'id'>): Promise<Client | null> => {
    try {
      const response = await fetch(`${BASE_URL}/clients`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(clientData)
      });
      const data = await response.json();
      if (data.client_id) {
        const newClient: Client = { id: parseInt(data.client_id, 10), ...clientData };
        setClients(prev => [...prev, newClient]);
        return newClient;
      }
    } catch (error) {
      console.error("Error adding client:", error);
    }
    return null;
  };

  const updateClient = async (id: number, clientData: Omit<Client, 'id'>): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/clients/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(clientData)
      });
      const data = await response.json();
        if (data.message === 'Client updated successfully') {
        setClients(prev =>
          prev.map(client => (client.id === id ? { id, ...clientData } : client))
        );
        return true;
      }
    } catch (error) {
      console.error("Error updating client:", error);
    }
    return false;
  };

  const deleteClient = async (id: number): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/clients/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.message === 'Client deleted successfully') {
        setClients(prev => prev.filter(client => client.id !== id));
        return true;
      }
    } catch (error) {
      console.error("Error deleting client:", error);
    }
    return false;
  };

  useEffect(() => {
    if (token) {
      loadClients();
    }
  }, [token]);

  return (
    <ClientsContext.Provider value={{ clients, loadClients, addClient, updateClient, deleteClient }}>
      {children}
    </ClientsContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: ConfigContext.tsx
Content:
// src/contexts/ConfigContext.tsx
import React, { createContext, useState, ReactNode, useEffect, useContext } from 'react';
import { Alert } from 'react-native';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface ConfigDetails {
  role: string;
  view_type: string;
  theme: string;
  font_size: string;
}

export interface ConfigForm {
  role: string;
  view_type: string;
  theme: string;
  font_size: string;
}

interface ConfigContextType {
  configDetails: ConfigDetails | null;
  loadConfig: () => Promise<void>;
  updateConfig: (configForm: ConfigForm) => Promise<void>;
}

export const ConfigContext = createContext<ConfigContextType | undefined>(undefined);

interface ConfigProviderProps {
  children: ReactNode;
}

export const ConfigProvider: React.FC<ConfigProviderProps> = ({ children }) => {
  const [configDetails, setConfigDetails] = useState<ConfigDetails | null>(null);
  const { userId, token } = useContext(AuthContext);

  const loadConfig = async (): Promise<void> => {
    if (!userId || !token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_configurations`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const data = await response.json();
        const configuration = data.configuration as ConfigDetails;
        setConfigDetails(configuration);
      } else {
        console.error('Error al obtener la configuraciÃ³n');
      }
    } catch (error: any) {
      console.error('Error en fetch de configuraciÃ³n:', error);
    }
  };

  const updateConfig = async (configForm: ConfigForm): Promise<void> => {
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_configurations`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(configForm),
      });
      if (response.ok) {
        // Actualiza el estado combinando la configuraciÃ³n previa con los nuevos datos
        setConfigDetails((prev) => (prev ? { ...prev, ...configForm } : null));
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error actualizando configuraciÃ³n');
      }
    } catch (error: any) {
      Alert.alert('Error', error.message);
    }
  };

  useEffect(() => {
    // Ejecutamos loadConfig cuando ya tengamos userId y token desde AuthContext
    if (userId && token) {
      void loadConfig();
    }
  }, [userId, token]);

  return (
    <ConfigContext.Provider value={{ configDetails, loadConfig, updateConfig }}>
      {children}
    </ConfigContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: FilesContext.tsx
Content:
import React, { createContext, useContext, ReactNode, useState } from 'react';
import { Alert } from 'react-native';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

// Define la interfaz que representa la informaciÃ³n de un archivo (metadata)
export interface FileData {
  id: number;
  user_id: number;
  original_name: string;
  file_type: string;
  file_size: number;
  created_at: string;
  updated_at: string;
}

// Define la forma en que se expondrÃ¡ el contexto (upload y getFile con cachÃ©)
interface FileContextType {
  uploadFile: (
    fileUri: string,
    originalName: string,
    fileType: string,
    fileSize: number
  ) => Promise<FileData | null>;
  getFile: (fileId: number) => Promise<Blob | null>;
}

// Inicializa el contexto con valores por defecto
export const FileContext = createContext<FileContextType>({
  uploadFile: async () => null,
  getFile: async () => null,
});

interface FileProviderProps {
  children: ReactNode;
}

export const FilesProvider = ({ children }: FileProviderProps) => {
  const { token } = useContext(AuthContext);
  // Estado para almacenar en cachÃ© los archivos descargados (clave: fileId)
  const [cachedFiles, setCachedFiles] = useState<{ [key: number]: Blob }>({});

  // FunciÃ³n interna para descargar un archivo desde el servidor
  const downloadFile = async (fileId: number): Promise<Blob | null> => {
    try {
      const response = await fetch(`${BASE_URL}/files/${fileId}`, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      if (response.ok) {
        const blob = await response.blob();
        // Almacenar en cachÃ© el blob descargado
        setCachedFiles(prevCache => ({ ...prevCache, [fileId]: blob }));
        return blob;
      } else {
        Alert.alert('Error', 'Error al descargar el archivo.');
      }
    } catch (error: any) {
      console.error('Error downloading file:', error);
      Alert.alert('Error', error.message);
    }
    return null;
  };

  // FunciÃ³n exportable que devuelve el archivo (con cachÃ©)
  const getFile = async (fileId: number): Promise<Blob | null> => {
    // Si el archivo ya estÃ¡ en cachÃ©, lo retorna directamente
    if (cachedFiles[fileId]) {
      return cachedFiles[fileId];
    }
    // Si no estÃ¡ en cachÃ©, lo descarga y lo almacena para futuras llamadas
    return await downloadFile(fileId);
  };

  // FunciÃ³n para subir un archivo al servidor
  const uploadFile = async (
    fileUri: string,
    originalName: string,
    fileType: string,
    fileSize: number
  ): Promise<FileData | null> => {
    try {
      const formData = new FormData();
      formData.append('file', {
        uri: fileUri,
        name: originalName,
        type: fileType,
      } as any); // Cast a any para compatibilidad en React Native

      const response = await fetch(`${BASE_URL}/files`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: formData,
      });

      if (!response.ok) {
        Alert.alert('Error', 'Error al subir el archivo.');
        return null;
      }

      const data = await response.json();
      if (data.file) {
        return data.file;
      }
    } catch (error: any) {
      console.error('Error uploading file:', error);
      Alert.alert('Error', error.message);
    }
    return null;
  };

  return (
    <FileContext.Provider value={{ uploadFile, getFile }}>
      {children}
    </FileContext.Provider>
  );
};

export default FilesProvider;

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: FoldersContext.tsx
Content:
// Archivo: contexts/FoldersContext.tsx

import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';
import { PermissionsContext } from '@/contexts/PermissionsContext';
import { Alert } from 'react-native';

export interface Folder {
  id: number;
  name: string;
  parent_id: number | null;
  folder_image_file_id: string | null;
  client_id: number;
  user_id: number;
}

export type FolderInput = {
  name: string;
  client_id: number;
  parent_id: number | null;
  folder_image_file_id: string | null;
};

interface FoldersContextType {
  folders: Folder[];
  loadFolders: () => void;
  addFolder: (folder: FolderInput) => Promise<boolean>;
  updateFolder: (id: number, folder: FolderInput) => Promise<boolean>;
  deleteFolder: (id: number) => Promise<boolean>;
}

export const FoldersContext = createContext<FoldersContextType>({
  folders: [],
  loadFolders: () => {},
  addFolder: async () => false,
  updateFolder: async () => false,
  deleteFolder: async () => false,
});

export const FoldersProvider = ({ children }: { children: ReactNode }) => {
  const [folders, setFolders] = useState<Folder[]>([]);
  const { token } = useContext(AuthContext);
  const { permissions } = useContext(PermissionsContext);

  const loadFolders = async () => {
    if (!permissions.includes('listFolders')) return;
    try {
      const response = await fetch(`${BASE_URL}/folders`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (data.folders) {
        setFolders(data.folders);
      }
    } catch (error) {
      console.error("Error loading folders:", error);
    }
  };

  const addFolder = async (folderData: FolderInput): Promise<boolean> => {
    if (!permissions.includes('addFolder')) return false;
    try {
      const response = await fetch(`${BASE_URL}/folders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(folderData),
      });
      const data = await response.json();
      if (data.folder_id) {
        await loadFolders();
        return true;
      }
    } catch (error) {
      console.error("Error adding folder:", error);
    }
    return false;
  };

  const updateFolder = async (id: number, folderData: FolderInput): Promise<boolean> => {
    if (!permissions.includes('updateFolder')) return false;
    try {
      const response = await fetch(`${BASE_URL}/folders/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(folderData),
      });
      const data = await response.json();
      if (data.message === 'Folder updated successfully') {
        await loadFolders();
        return true;
      }
    } catch (error) {
      console.error("Error updating folder:", error);
    }
    return false;
  };

  const deleteFolder = async (id: number): Promise<boolean> => {
    if (!permissions.includes('deleteFolder')) return false;
    try {
      const response = await fetch(`${BASE_URL}/folders/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (data.message === 'Folder deleted successfully') {
        await loadFolders();
        return true;
      }
    } catch (error) {
      console.error("Error deleting folder:", error);
    }
    return false;
  };

  useEffect(() => {
    if (token) {
      loadFolders();
    }
  }, [token, permissions]);

  return (
    <FoldersContext.Provider value={{ folders, loadFolders, addFolder, updateFolder, deleteFolder }}>
      {children}
    </FoldersContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: JobsContext.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/contexts/JobsContext.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface Job {
  id: number;
  user_id: number;
  client_id: number | null;
  product_service_id: number | null;
  folder_id: number | null;
  type_of_work: string;
  description: string;
  status: string;
  start_datetime: string | null;
  end_datetime: string | null;
  multiplicative_value: number;
  attached_files: string | null;
}

interface JobsContextType {
  jobs: Job[];
  loadJobs: () => void;
  addJob: (job: Omit<Job, 'id' | 'user_id'>) => Promise<Job | null>;
  updateJob: (id: number, job: Omit<Job, 'id' | 'user_id'>) => Promise<boolean>;
  deleteJob: (id: number) => Promise<boolean>;
}

export const JobsContext = createContext<JobsContextType>({
  jobs: [],
  loadJobs: () => {},
  addJob: async () => null,
  updateJob: async () => false,
  deleteJob: async () => false,
});

export const JobsProvider = ({ children }: { children: ReactNode }) => {
  const [jobs, setJobs] = useState<Job[]>([]);
  const { token } = useContext(AuthContext);

  const loadJobs = async () => {
    try {
      const res = await fetch(`${BASE_URL}/jobs`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await res.json();
      if (data.jobs) setJobs(data.jobs);
    } catch (err) {
      console.error('Error loading jobs:', err);
    }
  };

  const addJob = async (jobData: Omit<Job, 'id' | 'user_id'>): Promise<Job | null> => {
    try {
      const res = await fetch(`${BASE_URL}/jobs`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
        body: JSON.stringify(jobData),
      });
      const data = await res.json();
      if (data.job_id) {
        await loadJobs(); // asegura consistencia
        return { id: data.job_id, user_id: 0, ...jobData };
      }
    } catch (err) {
      console.error('Error adding job:', err);
    }
    return null;
  };

  const updateJob = async (id: number, jobData: Omit<Job, 'id' | 'user_id'>): Promise<boolean> => {
    try {
      const res = await fetch(`${BASE_URL}/jobs/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
        body: JSON.stringify(jobData),
      });
      const data = await res.json();
      if (data.message === 'Job updated successfully') {
        setJobs((prev) => prev.map((j) => (j.id === id ? { ...j, ...jobData } : j)));
        return true;
      }
    } catch (err) {
      console.error('Error updating job:', err);
    }
    return false;
  };

  const deleteJob = async (id: number): Promise<boolean> => {
    try {
      const res = await fetch(`${BASE_URL}/jobs/${id}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await res.json();
      if (data.message === 'Job deleted successfully') {
        setJobs((prev) => prev.filter((j) => j.id !== id));
        return true;
      }
    } catch (err) {
      console.error('Error deleting job:', err);
    }
    return false;
  };

  useEffect(() => {
    if (token) loadJobs();
  }, [token]);

  return (
    <JobsContext.Provider value={{ jobs, loadJobs, addJob, updateJob, deleteJob }}>
      {children}
    </JobsContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: output.txt
Content:
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: AuthContext.tsx
Content:
import React, { createContext, useState, useEffect, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as SecureStore from 'expo-secure-store';
import { Alert } from 'react-native';
import { BASE_URL } from '@/config/Index';

interface AuthContextProps {
  userId: string | null;
  isLoading: boolean;
  username: string | null;
  email: string | null;
  isOffline: boolean;
  token: string | null;
  login: (loginUsername: string, loginPassword: string) => Promise<void>;
  logout: () => Promise<void>;
  checkConnection: () => Promise<void>;
}

export const AuthContext = createContext<AuthContextProps>({
  userId: null,
  isLoading: true,
  username: null,
  email: null,
  isOffline: false,
  token: null,
  login: async () => {},
  logout: async () => {},
  checkConnection: async () => {},
});

// ConfiguraciÃƒÂ³n de tiempos y reintentos (ajustables)
const MAX_RETRY = 3;
const RETRY_DELAY = 10000; // 10 segundos de espera para reintentar
const TIMEOUT_DURATION = 10000; // 10 segundos de timeout en las peticiones
const PROFILE_CHECK_INTERVAL = 2 * 60 * 1000; // 2 minutos para revisar el perfil

// FunciÃƒÂ³n auxiliar para hacer fetch con timeout
const fetchWithTimeout = async (resource: string, options: any = {}) => {
  const { timeout = TIMEOUT_DURATION, ...rest } = options;
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(resource, { ...rest, signal: controller.signal });
    return response;
  } finally {
    clearTimeout(id);
  }
};

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [userId, setUserId] = useState<string | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [username, setUsername] = useState<string | null>(null);
  const [email, setEmail] = useState<string | null>(null);
  const [password, setPassword] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [isOffline, setIsOffline] = useState<boolean>(false);

  const saveItem = async (key: string, value: string) => {
    try {
      await SecureStore.setItemAsync(key, value);
    } catch (error) {
      console.error(`Error saving ${key}:`, error);
    }
  };

  const getItem = async (key: string): Promise<string | null> => {
    try {
      return await SecureStore.getItemAsync(key);
    } catch (error) {
      console.error(`Error getting ${key}:`, error);
      return null;
    }
  };

  const removeItem = async (key: string) => {
    try {
      await SecureStore.deleteItemAsync(key);
    } catch (error) {
      console.error(`Error deleting ${key}:`, error);
    }
  };

  // FunciÃƒÂ³n auxiliar para limpiar las credenciales (usada en logout y login fallido)
  const clearCredentials = async () => {
    await removeItem('token');
    await removeItem('user_id');
    await removeItem('username');
    await removeItem('password');
    await removeItem('token_expiration');
    await removeItem('email');
    setToken(null);
    setUserId(null);
    setUsername(null);
    setPassword(null);
    setEmail(null);
    setIsOffline(false);
  };

  const performLogin = useCallback(
    async (loginUsername: string, loginPassword: string, retryCount = 0) => {
      try {
        // PeticiÃƒÂ³n de login con timeout
        const response = await fetchWithTimeout(`${BASE_URL}/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: loginUsername, password: loginPassword }),
          timeout: TIMEOUT_DURATION,
        });

        if (response.ok) {
          const authHeader = response.headers.get('Authorization');
          const newToken =
            authHeader && authHeader.startsWith('Bearer ')
              ? authHeader.split(' ')[1]
              : null;
          // Si el token estÃƒÂ¡ vacÃƒÂ­o, se considera que las credenciales fallaron
          if (!newToken) {
            await clearCredentials();
            throw new Error('Credenciales invÃƒÂ¡lidas, por favor intente nuevamente.');
          }

          // Obtenemos el perfil para extraer el email y demÃƒÂ¡s datos
          const profileResponse = await fetchWithTimeout(`${BASE_URL}/profile`, {
            method: 'GET',
            headers: {
              Authorization: `Bearer ${newToken}`,
              'Content-Type': 'application/json',
            },
            timeout: TIMEOUT_DURATION,
          });

          if (!profileResponse.ok) {
            throw new Error('No se pudo obtener el perfil del usuario');
          }

          const profileData = await profileResponse.json();
          const { id, email: userEmail } = profileData.user;
          const nowInArgentina = new Date(new Date().toLocaleString("en-US", { timeZone: "America/Argentina/Buenos_Aires" }));
          const expirationTime = (nowInArgentina.getTime() + 3600 * 1000).toString();

          await saveItem('token', newToken);
          await saveItem('user_id', id.toString());
          await saveItem('username', loginUsername);
          await saveItem('password', loginPassword);
          await saveItem('token_expiration', expirationTime);
          await saveItem('email', userEmail);

          setToken(newToken);
          setUserId(id.toString());
          setUsername(loginUsername);
          setPassword(loginPassword);
          setEmail(userEmail);

          // ConexiÃƒÂ³n exitosa, marcar como online
          setIsOffline(false);
        } else {
          const errorResult = await response.json();
          throw new Error(errorResult.error || 'Error en el login');
        }
      } catch (error: any) {
        // Si es un timeout y aÃƒÂºn no se excede el nÃƒÂºmero de reintentos, reintenta despuÃƒÂ©s de un retardo
        if (
          (error.name === 'AbortError' || error.message.toLowerCase().includes('timeout')) &&
          retryCount < MAX_RETRY
        ) {
          setTimeout(() => {
            performLogin(loginUsername, loginPassword, retryCount + 1);
          }, RETRY_DELAY);
          return;
        }
        // Si es un error de red, marcar como offline
        if (error.message && error.message.toLowerCase().includes('network')) {
          setIsOffline(true);
        } else {
          setIsOffline(false);
        }
        Alert.alert('Error de Login', error.message);
      }
    },
    []
  );

  const login = useCallback(
    async (loginUsername: string, loginPassword: string) => {
      await performLogin(loginUsername, loginPassword);
    },
    [performLogin]
  );

  const checkTokenValidity = useCallback(async (): Promise<boolean> => {
    const expiration = await getItem('token_expiration');
    if (!expiration) return false;
    const expirationTime = parseInt(expiration, 10);
    const now = new Date().getTime();
    return now < expirationTime;
  }, []);

  const autoLogin = useCallback(async () => {
    const storedUsername = await getItem('username');
    const storedPassword = await getItem('password');
    const storedToken = await getItem('token');
    const storedEmail = await getItem('email');
    const tokenValid = await checkTokenValidity();

    if (storedUsername && storedPassword && storedToken && tokenValid) {
      const storedUserId = await getItem('user_id');
      setToken(storedToken);
      setUserId(storedUserId);
      setUsername(storedUsername);
      setPassword(storedPassword);
      setEmail(storedEmail);
    } else if (storedUsername && storedPassword) {
      await performLogin(storedUsername, storedPassword);
    }
    setIsLoading(false);
  }, [checkTokenValidity, performLogin]);

  const logout = useCallback(async () => {
    await clearCredentials();
  }, []);

  const checkConnection = useCallback(async () => {
    if (!token) {
      setIsOffline(true);
      return;
    }
    try {
      const response = await fetchWithTimeout(`${BASE_URL}/profile`, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        timeout: TIMEOUT_DURATION,
      });
      
      // Si recibimos 401, el token es invÃƒÂ¡lido o ha expirado, se reintenta el login
      if (response.status === 401) {
        if (username && password) {
          await performLogin(username, password);
        } else {
          setIsOffline(true);
        }
        return;
      }

      if (!response.ok) {
        setIsOffline(true);
      } else {
        setIsOffline(false);
      }
    } catch (error) {
      setIsOffline(true);
    }
  }, [token, username, password, performLogin]);

  useEffect(() => {
    autoLogin();
  }, [autoLogin]);

  // Chequeo periÃƒÂ³dico de la validez del token cada 5 minutos
  useEffect(() => {
    const interval = setInterval(async () => {
      const valid = await checkTokenValidity();
      if (!valid && username && password) {
        await performLogin(username, password);
      }
    }, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [checkTokenValidity, performLogin, username, password]);

  // Chequeo periÃƒÂ³dico del perfil cada 2 minutos para confirmar que sigue logueado
  useEffect(() => {
    const interval = setInterval(async () => {
      await checkConnection();
      // Si no estÃƒÂ¡ online y hay credenciales almacenadas, se reintenta el login automÃƒÂ¡ticamente
      if (isOffline && username && password) {
        await performLogin(username, password);
      }
    }, PROFILE_CHECK_INTERVAL);
    return () => clearInterval(interval);
  }, [checkConnection, isOffline, username, password, performLogin]);

  return (
    <AuthContext.Provider
      value={{
        userId,
        isLoading,
        username,
        email,
        isOffline,
        token,
        login,
        logout,
        checkConnection,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export default AuthProvider;

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: CashBoxesContext.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/contexts/CashBoxesContext.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface CashBox {
  id: number;
  name: string;
  image_file_id: string | null;
  user_id: number;
  // Puedes agregar mÃƒÂ¡s campos si los requiere tu API
}

interface CashBoxesContextType {
  cashBoxes: CashBox[];
  loadCashBoxes: () => void;
  addCashBox: (cashBox: Omit<CashBox, 'id' | 'user_id'>) => Promise<CashBox | null>;
  updateCashBox: (id: number, cashBox: Omit<CashBox, 'id' | 'user_id'>) => Promise<boolean>;
  deleteCashBox: (id: number) => Promise<boolean>;
  listCashBoxHistory: (id: number) => Promise<any[]>; // Opcional, para historial
}

export const CashBoxesContext = createContext<CashBoxesContextType>({
  cashBoxes: [],
  loadCashBoxes: () => {},
  addCashBox: async () => null,
  updateCashBox: async () => false,
  deleteCashBox: async () => false,
  listCashBoxHistory: async () => []
});

export const CashBoxesProvider = ({ children }: { children: ReactNode }) => {
  const [cashBoxes, setCashBoxes] = useState<CashBox[]>([]);
  const { token } = useContext(AuthContext);

  const loadCashBoxes = async () => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.cash_boxes) {
        setCashBoxes(data.cash_boxes);
      }
    } catch (error) {
      console.error("Error loading cash boxes:", error);
    }
  };

  const addCashBox = async (cashBoxData: Omit<CashBox, 'id' | 'user_id'>): Promise<CashBox | null> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(cashBoxData)
      });
      const data = await response.json();
      if (data.cash_box_id) {
        const newCashBox: CashBox = { id: parseInt(data.cash_box_id, 10), user_id: 0, ...cashBoxData };
        setCashBoxes(prev => [...prev, newCashBox]);
        return newCashBox;
      }
    } catch (error) {
      console.error("Error adding cash box:", error);
    }
    return null;
  };

  const updateCashBox = async (id: number, cashBoxData: Omit<CashBox, 'id' | 'user_id'>): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(cashBoxData)
      });
      const data = await response.json();
      if (data.message === 'Cash box updated successfully') {
        setCashBoxes(prev =>
          prev.map(cb => (cb.id === id ? { ...cb, ...cashBoxData } : cb))
        );
        return true;
      }
    } catch (error) {
      console.error("Error updating cash box:", error);
    }
    return false;
  };

  const deleteCashBox = async (id: number): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.message === 'Cash box deleted successfully') {
        setCashBoxes(prev => prev.filter(cb => cb.id !== id));
        return true;
      }
    } catch (error) {
      console.error("Error deleting cash box:", error);
    }
    return false;
  };

  const listCashBoxHistory = async (id: number): Promise<any[]> => {
    try {
      const response = await fetch(`${BASE_URL}/cash_boxes/${id}/history`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.history) {
        return data.history;
      }
    } catch (error) {
      console.error("Error listing cash box history:", error);
    }
    return [];
  };

  useEffect(() => {
    if (token) {
      loadCashBoxes();
    }
  }, [token]);

  return (
    <CashBoxesContext.Provider value={{ cashBoxes, loadCashBoxes, addCashBox, updateCashBox, deleteCashBox, listCashBoxHistory }}>
      {children}
    </CashBoxesContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: ClientsContext.tsx
Content:
// /contexts/ClientsContext.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface Client {
  id: number;
  business_name: string;
  tax_id: string;
  email: string;
  brand_file_id: string | null;
  phone: string;
  address: string;
}

interface ClientsContextValue {
  clients: Client[];
  loadClients: () => void;
  addClient: (client: Omit<Client, 'id'>) => Promise<Client | null>;
  updateClient: (id: number, client: Omit<Client, 'id'>) => Promise<boolean>;
  deleteClient: (id: number) => Promise<boolean>;
}

export const ClientsContext = createContext<ClientsContextValue>({
  clients: [],
  loadClients: () => {},
  addClient: async () => null,
  updateClient: async () => false,
  deleteClient: async () => false,
});

export const ClientsProvider = ({ children }: { children: ReactNode }) => {
  const [clients, setClients] = useState<Client[]>([]);
  const { token } = useContext(AuthContext);

  const loadClients = async () => {
    
    try {
      const response = await fetch(`${BASE_URL}/clients`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.clients) {
        setClients(data.clients);
      }
    } catch (error) {
      console.error("Error loading clients:", error);
    }
  };

  const addClient = async (clientData: Omit<Client, 'id'>): Promise<Client | null> => {
    try {
      const response = await fetch(`${BASE_URL}/clients`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(clientData)
      });
      const data = await response.json();
      if (data.client_id) {
        const newClient: Client = { id: parseInt(data.client_id, 10), ...clientData };
        setClients(prev => [...prev, newClient]);
        return newClient;
      }
    } catch (error) {
      console.error("Error adding client:", error);
    }
    return null;
  };

  const updateClient = async (id: number, clientData: Omit<Client, 'id'>): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/clients/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(clientData)
      });
      const data = await response.json();
        if (data.message === 'Client updated successfully') {
        setClients(prev =>
          prev.map(client => (client.id === id ? { id, ...clientData } : client))
        );
        return true;
      }
    } catch (error) {
      console.error("Error updating client:", error);
    }
    return false;
  };

  const deleteClient = async (id: number): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/clients/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`
        }
      });
      const data = await response.json();
      if (data.message === 'Client deleted successfully') {
        setClients(prev => prev.filter(client => client.id !== id));
        return true;
      }
    } catch (error) {
      console.error("Error deleting client:", error);
    }
    return false;
  };

  useEffect(() => {
    if (token) {
      loadClients();
    }
  }, [token]);

  return (
    <ClientsContext.Provider value={{ clients, loadClients, addClient, updateClient, deleteClient }}>
      {children}
    </ClientsContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: ConfigContext.tsx
Content:
// src/contexts/ConfigContext.tsx
import React, { createContext, useState, ReactNode, useEffect, useContext } from 'react';
import { Alert } from 'react-native';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface ConfigDetails {
  role: string;
  view_type: string;
  theme: string;
  font_size: string;
}

export interface ConfigForm {
  role: string;
  view_type: string;
  theme: string;
  font_size: string;
}

interface ConfigContextType {
  configDetails: ConfigDetails | null;
  loadConfig: () => Promise<void>;
  updateConfig: (configForm: ConfigForm) => Promise<void>;
}

export const ConfigContext = createContext<ConfigContextType | undefined>(undefined);

interface ConfigProviderProps {
  children: ReactNode;
}

export const ConfigProvider: React.FC<ConfigProviderProps> = ({ children }) => {
  const [configDetails, setConfigDetails] = useState<ConfigDetails | null>(null);
  const { userId, token } = useContext(AuthContext);

  const loadConfig = async (): Promise<void> => {
    if (!userId || !token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_configurations`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const data = await response.json();
        const configuration = data.configuration as ConfigDetails;
        setConfigDetails(configuration);
      } else {
        console.error('Error al obtener la configuraciÃƒÂ³n');
      }
    } catch (error: any) {
      console.error('Error en fetch de configuraciÃƒÂ³n:', error);
    }
  };

  const updateConfig = async (configForm: ConfigForm): Promise<void> => {
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_configurations`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(configForm),
      });
      if (response.ok) {
        // Actualiza el estado combinando la configuraciÃƒÂ³n previa con los nuevos datos
        setConfigDetails((prev) => (prev ? { ...prev, ...configForm } : null));
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error actualizando configuraciÃƒÂ³n');
      }
    } catch (error: any) {
      Alert.alert('Error', error.message);
    }
  };

  useEffect(() => {
    // Ejecutamos loadConfig cuando ya tengamos userId y token desde AuthContext
    if (userId && token) {
      void loadConfig();
    }
  }, [userId, token]);

  return (
    <ConfigContext.Provider value={{ configDetails, loadConfig, updateConfig }}>
      {children}
    </ConfigContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: FilesContext.tsx
Content:
import React, { createContext, useContext, ReactNode, useState } from 'react';
import { Alert } from 'react-native';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

// Define la interfaz que representa la informaciÃƒÂ³n de un archivo (metadata)
export interface FileData {
  id: number;
  user_id: number;
  original_name: string;
  file_type: string;
  file_size: number;
  created_at: string;
  updated_at: string;
}

// Define la forma en que se expondrÃƒÂ¡ el contexto (upload y getFile con cachÃƒÂ©)
interface FileContextType {
  uploadFile: (
    fileUri: string,
    originalName: string,
    fileType: string,
    fileSize: number
  ) => Promise<FileData | null>;
  getFile: (fileId: number) => Promise<Blob | null>;
}

// Inicializa el contexto con valores por defecto
export const FileContext = createContext<FileContextType>({
  uploadFile: async () => null,
  getFile: async () => null,
});

interface FileProviderProps {
  children: ReactNode;
}

export const FilesProvider = ({ children }: FileProviderProps) => {
  const { token } = useContext(AuthContext);
  // Estado para almacenar en cachÃƒÂ© los archivos descargados (clave: fileId)
  const [cachedFiles, setCachedFiles] = useState<{ [key: number]: Blob }>({});

  // FunciÃƒÂ³n interna para descargar un archivo desde el servidor
  const downloadFile = async (fileId: number): Promise<Blob | null> => {
    try {
      const response = await fetch(`${BASE_URL}/files/${fileId}`, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      if (response.ok) {
        const blob = await response.blob();
        // Almacenar en cachÃƒÂ© el blob descargado
        setCachedFiles(prevCache => ({ ...prevCache, [fileId]: blob }));
        return blob;
      } else {
        Alert.alert('Error', 'Error al descargar el archivo.');
      }
    } catch (error: any) {
      console.error('Error downloading file:', error);
      Alert.alert('Error', error.message);
    }
    return null;
  };

  // FunciÃƒÂ³n exportable que devuelve el archivo (con cachÃƒÂ©)
  const getFile = async (fileId: number): Promise<Blob | null> => {
    // Si el archivo ya estÃƒÂ¡ en cachÃƒÂ©, lo retorna directamente
    if (cachedFiles[fileId]) {
      return cachedFiles[fileId];
    }
    // Si no estÃƒÂ¡ en cachÃƒÂ©, lo descarga y lo almacena para futuras llamadas
    return await downloadFile(fileId);
  };

  // FunciÃƒÂ³n para subir un archivo al servidor
  const uploadFile = async (
    fileUri: string,
    originalName: string,
    fileType: string,
    fileSize: number
  ): Promise<FileData | null> => {
    try {
      const formData = new FormData();
      formData.append('file', {
        uri: fileUri,
        name: originalName,
        type: fileType,
      } as any); // Cast a any para compatibilidad en React Native

      const response = await fetch(`${BASE_URL}/files`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
        },
        body: formData,
      });

      if (!response.ok) {
        Alert.alert('Error', 'Error al subir el archivo.');
        return null;
      }

      const data = await response.json();
      if (data.file) {
        return data.file;
      }
    } catch (error: any) {
      console.error('Error uploading file:', error);
      Alert.alert('Error', error.message);
    }
    return null;
  };

  return (
    <FileContext.Provider value={{ uploadFile, getFile }}>
      {children}
    </FileContext.Provider>
  );
};

export default FilesProvider;

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: FoldersContext.tsx
Content:
// Archivo: contexts/FoldersContext.tsx

import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';
import { PermissionsContext } from '@/contexts/PermissionsContext';
import { Alert } from 'react-native';

export interface Folder {
  id: number;
  name: string;
  parent_id: number | null;
  folder_image_file_id: string | null;
  client_id: number;
  user_id: number;
}

export type FolderInput = {
  name: string;
  client_id: number;
  parent_id: number | null;
  folder_image_file_id: string | null;
};

interface FoldersContextType {
  folders: Folder[];
  loadFolders: () => void;
  addFolder: (folder: FolderInput) => Promise<boolean>;
  updateFolder: (id: number, folder: FolderInput) => Promise<boolean>;
  deleteFolder: (id: number) => Promise<boolean>;
}

export const FoldersContext = createContext<FoldersContextType>({
  folders: [],
  loadFolders: () => {},
  addFolder: async () => false,
  updateFolder: async () => false,
  deleteFolder: async () => false,
});

export const FoldersProvider = ({ children }: { children: ReactNode }) => {
  const [folders, setFolders] = useState<Folder[]>([]);
  const { token } = useContext(AuthContext);
  const { permissions } = useContext(PermissionsContext);

  const loadFolders = async () => {
    if (!permissions.includes('listFolders')) return;
    try {
      const response = await fetch(`${BASE_URL}/folders`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (data.folders) {
        setFolders(data.folders);
      }
    } catch (error) {
      console.error("Error loading folders:", error);
    }
  };

  const addFolder = async (folderData: FolderInput): Promise<boolean> => {
    if (!permissions.includes('addFolder')) return false;
    try {
      const response = await fetch(`${BASE_URL}/folders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(folderData),
      });
      const data = await response.json();
      if (data.folder_id) {
        await loadFolders();
        return true;
      }
    } catch (error) {
      console.error("Error adding folder:", error);
    }
    return false;
  };

  const updateFolder = async (id: number, folderData: FolderInput): Promise<boolean> => {
    if (!permissions.includes('updateFolder')) return false;
    try {
      const response = await fetch(`${BASE_URL}/folders/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(folderData),
      });
      const data = await response.json();
      if (data.message === 'Folder updated successfully') {
        await loadFolders();
        return true;
      }
    } catch (error) {
      console.error("Error updating folder:", error);
    }
    return false;
  };

  const deleteFolder = async (id: number): Promise<boolean> => {
    if (!permissions.includes('deleteFolder')) return false;
    try {
      const response = await fetch(`${BASE_URL}/folders/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (data.message === 'Folder deleted successfully') {
        await loadFolders();
        return true;
      }
    } catch (error) {
      console.error("Error deleting folder:", error);
    }
    return false;
  };

  useEffect(() => {
    if (token) {
      loadFolders();
    }
  }, [token, permissions]);

  return (
    <FoldersContext.Provider value={{ folders, loadFolders, addFolder, updateFolder, deleteFolder }}>
      {children}
    </FoldersContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: PermissionsContext.tsx
Content:
import React, { createContext, useState, useEffect, useContext, useCallback } from 'react';
import { Alert } from 'react-native';
import { AuthContext } from '@/contexts/AuthContext';
import { BASE_URL } from '@/config/Index';

interface PermissionsContextProps {
  permissions: string[]; // Array de cadenas con los nombres de los permisos
  loading: boolean;
  refreshPermissions: () => Promise<void>;
}

export const PermissionsContext = createContext<PermissionsContextProps>({
  permissions: [],
  loading: false,
  refreshPermissions: async () => {},
});

export const PermissionsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { token, userId } = useContext(AuthContext);
  const [permissions, setPermissions] = useState<string[]>([]);
  const [loading, setLoading] = useState<boolean>(false);

  const fetchPermissions = useCallback(async () => {
    // Si no hay token o userId, limpiamos los permisos.
    if (!token || !userId) {
      setPermissions([]);
      return;
    }
    setLoading(true);
    try {
      // Se realizan ambas peticiones de forma concurrente:
      const [userRes, globalRes] = await Promise.all([
        fetch(`${BASE_URL}/permissions/user/${userId}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        }),
        fetch(`${BASE_URL}/permissions/global`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        }),
      ]);
      
      const userData = await userRes.json();
      const globalData = await globalRes.json();

      // Suponemos que la respuesta tiene la forma: { permissions: [ { id, sector, ... }, ... ] }
      const userPerms: string[] = userData.permissions?.map((p: any) => p.sector) || [];
      const globalPerms: string[] = globalData.permissions?.map((p: any) => p.sector) || [];
      
      // Unir ambas listas sin duplicados
      const mergedPermissions = Array.from(new Set([...userPerms, ...globalPerms]));
      setPermissions(mergedPermissions);
    } catch (error) {
      console.error("Error fetching permissions", error);
      Alert.alert("Error", "No se pudieron cargar los permisos.");
    } finally {
      setLoading(false);
    }
  }, [token, userId]);

  useEffect(() => {
    fetchPermissions();
  }, [fetchPermissions]);

  // Refrescar periÃ³dicamente cada 5 minutos
  useEffect(() => {
    const interval = setInterval(() => {
      fetchPermissions();
    }, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [fetchPermissions]);

  return (
    <PermissionsContext.Provider value={{ permissions, loading, refreshPermissions: fetchPermissions }}>
      {children}
    </PermissionsContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: ProductsServicesContext.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/contexts/ProductsServicesContext.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface ProductService {
  id: number;
  description: string;
  category: string;
  price: number;
  cost: number;
  difficulty: string;
  item_type: 'product' | 'service';
  stock: number | null;
  product_image_file_id: string | null;
  user_id: number;
}

interface ProductsServicesContextType {
  productsServices: ProductService[];
  loadProductsServices: () => void;
  addProductService: (item: Omit<ProductService, 'id' | 'user_id'>) => Promise<ProductService | null>;
  updateProductService: (id: number, item: Omit<ProductService, 'id' | 'user_id'>) => Promise<boolean>;
  deleteProductService: (id: number) => Promise<boolean>;
}

export const ProductsServicesContext = createContext<ProductsServicesContextType>({
  productsServices: [],
  loadProductsServices: () => {},
  addProductService: async () => null,
  updateProductService: async () => false,
  deleteProductService: async () => false,
});

export const ProductsServicesProvider = ({ children }: { children: ReactNode }) => {
  const [productsServices, setProductsServices] = useState<ProductService[]>([]);
  const { token } = useContext(AuthContext);

  const loadProductsServices = async () => {
    try {
      const response = await fetch(`${BASE_URL}/products_services`, {
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }
      });
      const data = await response.json();
      if (data.products_services) setProductsServices(data.products_services);
    } catch (error) {
      console.error('Error loading products/services:', error);
    }
  };

  const addProductService = async (item: Omit<ProductService, 'id' | 'user_id'>): Promise<ProductService | null> => {
    try {
      const response = await fetch(`${BASE_URL}/products_services`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
        body: JSON.stringify(item),
      });
      const data = await response.json();
      if (data.id) {
        const newItem: ProductService = { id: data.id, user_id: 0, ...item };
        setProductsServices(prev => [...prev, newItem]);
        return newItem;
      }
    } catch (error) {
      console.error('Error adding product/service:', error);
    }
    return null;
  };

  const updateProductService = async (id: number, item: Omit<ProductService, 'id' | 'user_id'>): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/products_services/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
        body: JSON.stringify(item),
      });
      const data = await response.json();
      if (data.message === 'Record updated successfully') {
        setProductsServices(prev => prev.map(p => (p.id === id ? { ...p, ...item } : p)));
        return true;
      }
    } catch (error) {
      console.error('Error updating product/service:', error);
    }
    return false;
  };

  const deleteProductService = async (id: number): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/products_services/${id}`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` }
      });
      const data = await response.json();
      if (data.message === 'Record deleted successfully') {
        setProductsServices(prev => prev.filter(p => p.id !== id));
        return true;
      }
    } catch (error) {
      console.error('Error deleting product/service:', error);
    }
    return false;
  };

  useEffect(() => {
    if (token) loadProductsServices();
  }, [token]);

  return (
    <ProductsServicesContext.Provider value={{ productsServices, loadProductsServices, addProductService, updateProductService, deleteProductService }}>
      {children}
    </ProductsServicesContext.Provider>
  );
};
---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: ProfileContext.tsx
Content:
// ProfileContext.tsx
import React, { createContext, useState, useContext, ReactNode } from 'react';
import { Alert } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { AuthContext } from '@/contexts/AuthContext';
import { BASE_URL } from '@/config/Index';

export interface ProfileDetails {
  id?: number;
  full_name: string;
  phone: string;
  address: string;
  cuit: string;
  profile_file_id?: string;
}

export interface ProfileForm {
  full_name: string;
  phone: string;
  address: string;
  cuit: string;
  profile_file_id: string;
}

interface ProfileContextType {
  profileDetails: ProfileDetails | null;
  loadProfile: () => Promise<void>;
  updateProfile: (profileForm: ProfileForm) => Promise<void>;
  updateImage: (newFileId: string, profileForm: ProfileForm) => Promise<void>;
  deleteAccount: () => Promise<void>;
}

export const ProfileContext = createContext<ProfileContextType | undefined>(undefined);

interface ProfileProviderProps {
  children: ReactNode;
}

export const ProfileProvider: React.FC<ProfileProviderProps> = ({ children }) => {
  const [profileDetails, setProfileDetails] = useState<ProfileDetails | null>(null);
  const { userId, token, logout } = useContext(AuthContext);
  const router = useRouter();

  // Cargar perfil desde el servidor
  const loadProfile = async () => {
    if (!userId || !token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_profile`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const data = await response.json();
        const profile = data.profile as ProfileDetails;
        setProfileDetails(profile);
      } else {
        console.error('Error loading profile');
      }
    } catch (error) {
      console.error('Fetch error:', error);
    }
  };

  // Actualizar perfil (PUT)
  const updateProfile = async (profileForm: ProfileForm) => {
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_profile`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          full_name: profileForm.full_name,
          phone: profileForm.phone,
          address: profileForm.address,
          cuit: profileForm.cuit,
          profile_file_id:
            profileForm.profile_file_id === '' ? null : parseInt(profileForm.profile_file_id),
        }),
      });
      if (response.ok) {
        // Actualizamos el estado local combinando los cambios
        setProfileDetails(prev => (prev ? { ...prev, ...profileForm } : null));
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error updating profile');
      }
    } catch (error: any) {
      Alert.alert('Error', error.message);
    }
  };

  // Actualizar imagen de perfil
  const updateImage = async (newFileId: string, profileForm: ProfileForm) => {
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_profile`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          full_name: profileForm.full_name,
          phone: profileForm.phone,
          address: profileForm.address,
          cuit: profileForm.cuit,
          profile_file_id: newFileId,
        }),
      });
      if (response.ok) {
        // Recargamos el perfil para reflejar los cambios
        await loadProfile();
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error updating profile image');
      }
    } catch (error: any) {
      Alert.alert('Error', error.message);
    }
  };

  // Eliminar cuenta
  const deleteAccount = async () => {
    Alert.alert(
      'Delete Account',
      'This action is irreversible. Do you want to proceed?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            if (!token || !userId) return;
            try {
              const response = await fetch(`${BASE_URL}/users/${userId}`, {
                method: 'DELETE',
                headers: { Authorization: `Bearer ${token}` },
              });
              if (response.ok) {
                await AsyncStorage.clear();
                Alert.alert('Account deleted');
                await logout();
                router.replace('./login');
              } else {
                Alert.alert('Error', 'Could not delete account.');
              }
            } catch (error: any) {
              Alert.alert('Error', error.message);
            }
          },
        },
      ]
    );
  };

  return (
    <ProfileContext.Provider
      value={{ profileDetails, loadProfile, updateProfile, updateImage, deleteAccount }}
    >
      {children}
    </ProfileContext.Provider>
  );
};

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/contexts
File: StatusesContext.tsx
Content:
// contexts/StatusesContext.tsx
import React, { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { BASE_URL } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';

export interface Status {
  id: number;
  label: string;
  value: string;
  background_color: string;
  order_index: number;
  created_at: string;
  updated_at: string;
}

interface StatusesContextType {
  statuses: Status[];
  loadStatuses: () => void;
  addStatus: (status: Omit<Status, 'id' | 'created_at' | 'updated_at'>) => Promise<Status | null>;
  updateStatus: (id: number, status: Omit<Status, 'id' | 'created_at' | 'updated_at'>) => Promise<boolean>;
  deleteStatus: (id: number) => Promise<boolean>;
  reorderStatuses: (orderedIds: number[]) => Promise<boolean>;
}

export const StatusesContext = createContext<StatusesContextType>({
  statuses: [],
  loadStatuses: () => {},
  addStatus: async () => null,
  updateStatus: async () => false,
  deleteStatus: async () => false,
  reorderStatuses: async () => false,
});

export const StatusesProvider = ({ children }: { children: ReactNode }) => {
  const [statuses, setStatuses] = useState<Status[]>([]);
  const { token } = useContext(AuthContext);

  const loadStatuses = async () => {
    try {
      const response = await fetch(`${BASE_URL}/statuses`, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (data.statuses) {
        setStatuses(data.statuses);
      }
    } catch (error) {
      console.error("Error loading statuses:", error);
    }
  };

  const addStatus = async (statusData: Omit<Status, 'id' | 'created_at' | 'updated_at'>): Promise<Status | null> => {
    try {
      const response = await fetch(`${BASE_URL}/statuses`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(statusData),
      });
      const data = await response.json();
      if (data.status_id) {
        const newStatus: Status = {
          id: parseInt(data.status_id, 10),
          created_at: "", // El API deberÃ­a devolver estas fechas o se recargan en loadStatuses
          updated_at: "",
          ...statusData,
        };
        setStatuses(prev => [...prev, newStatus]);
        return newStatus;
      }
    } catch (error) {
      console.error("Error adding status:", error);
    }
    return null;
  };

  const updateStatus = async (
    id: number,
    statusData: Omit<Status, 'id' | 'created_at' | 'updated_at'>
  ): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/statuses/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(statusData),
      });
      const data = await response.json();
      if (data.message === 'Status updated successfully') {
        setStatuses(prev => prev.map(s => (s.id === id ? { ...s, ...statusData } : s)));
        return true;
      }
    } catch (error) {
      console.error("Error updating status:", error);
    }
    return false;
  };

  const deleteStatus = async (id: number): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/statuses/${id}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (data.message === 'Status deleted successfully') {
        setStatuses(prev => prev.filter(s => s.id !== id));
        return true;
      }
    } catch (error) {
      console.error("Error deleting status:", error);
    }
    return false;
  };

  const reorderStatuses = async (orderedIds: number[]): Promise<boolean> => {
    try {
      const response = await fetch(`${BASE_URL}/statuses/reorder`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ ordered_ids: orderedIds }),
      });
      const data = await response.json();
      if (data.message === 'Statuses reordered successfully') {
        await loadStatuses();
        return true;
      }
    } catch (error) {
      console.error("Error reordering statuses:", error);
    }
    return false;
  };

  useEffect(() => {
    if (token) {
      loadStatuses();
    }
  }, [token]);

  return (
    <StatusesContext.Provider
      value={{ statuses, loadStatuses, addStatus, updateStatus, deleteStatus, reorderStatuses }}
    >
      {children}
    </StatusesContext.Provider>
  );
};

---
