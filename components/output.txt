Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: CircleImagePicker.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/components/CircleImagePicker.tsx

import React, { useState, useEffect, useContext } from 'react';
import {
  View,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Image,
  ActivityIndicator,
  Text,
  StyleProp,
  ViewStyle,
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import * as FileSystem from 'expo-file-system';
import { MAX_FILE_SIZE } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';
import { FileContext } from '@/contexts/FilesContext';

/**
 * Props del componente CircleImagePicker.
 */
interface CircleImagePickerProps {
  /**
   * ID de archivo en el servidor. Si se proporciona, se descargarÃ¡ la imagen.
   */
  fileId?: string | null;
  /**
   * URI local (o remota) a usar directamente.
   * Tiene prioridad sobre fileId.
   */
  imageUri?: string | null;
  /**
   * Indica si se muestra el Ã­cono de cÃ¡mara para cambiar la imagen.
   */
  editable?: boolean;
  /**
   * TamaÃ±o (ancho/alto) del cÃ­rculo.
   */
  size?: number;
  /**
   * Callback que se dispara cuando se sube con Ã©xito una nueva imagen
   * y se obtiene un nuevo fileId del servidor.
   */
  onImageChange?: (newFileId: string) => void;
  /**
   * Indica si se debe recortar la imagen tras seleccionarla.
   */
  crop?: boolean;
  /**
   * RazÃ³n de aspecto para el recorte (por ejemplo, 1 para 1:1).
   * Si no se especifica, se usa 1 (cuadrado).
   */
  cropAspect?: number;
  /**
   * Estilo adicional para el contenedor principal.
   */
  style?: StyleProp<ViewStyle>;
}

export default function CircleImagePicker({
  fileId = null,
  imageUri = null,
  editable = false,
  size = 80,
  crop = false,
  cropAspect = 1,
  onImageChange,
  style,
}: CircleImagePickerProps): JSX.Element {
  const [loading, setLoading] = useState<boolean>(false);
  const [internalUri, setInternalUri] = useState<string | null>(null);
  const [hasError, setHasError] = useState<boolean>(false);
  const { token } = useContext(AuthContext);
  // Se importan las funciones del contexto FileContext
  const { uploadFile, getFile } = useContext(FileContext);

  // Cargar la imagen segÃºn imageUri o fileId
  useEffect(() => {
    if (imageUri) {
      setInternalUri(imageUri);
      setHasError(false);
    } else if (fileId) {
      void loadFileFromServer(fileId);
    } else {
      setInternalUri(null);
      setHasError(false);
    }
  }, [fileId, imageUri]);

  /**
   * Descarga la imagen desde el servidor usando un fileId.
   */
  const loadFileFromServer = async (fId: string) => {
    try {
      setLoading(true);
      setHasError(false);
      if (!token) {
        setHasError(true);
        setLoading(false);
        return;
      }
      // Usamos getFile del contexto, que maneja la cachÃ©
      const uri = await getFile(parseInt(fId));
      if (uri) {
        setInternalUri(uri);
        setHasError(false);
      } else {
        setHasError(true);
      }
      setLoading(false);
     
    } catch (error) {
      setHasError(true);
      setLoading(false);
    }
  };

  /**
   * Solicita permisos y abre la fuente de imagen (cÃ¡mara o galerÃ­a).
   */
  const pickImageFromSource = async (fromCamera: boolean) => {
    if (fromCamera) {
      const { status } = await ImagePicker.requestCameraPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permiso denegado', 'Se requieren permisos de cÃ¡mara.');
        return null;
      }
      return await ImagePicker.launchCameraAsync({ quality: 0.7 });
    } else {
      const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permiso denegado', 'Se requieren permisos de galerÃ­a.');
        return null;
      }
      return await ImagePicker.launchImageLibraryAsync({ quality: 0.7 });
    }
  };

  /**
   * Recorta la imagen de forma centrada segÃºn el aspecto deseado.
   */
  const cropImage = async (
    uri: string,
    aspect: number,
    width: number,
    height: number
  ): Promise<string> => {
    let cropWidth = width;
    let cropHeight = height;
    let originX = 0;
    let originY = 0;
    const currentRatio = width / height;
    if (currentRatio > aspect) {
      cropWidth = height * aspect;
      originX = (width - cropWidth) / 2;
    } else {
      cropHeight = width / aspect;
      originY = (height - cropHeight) / 2;
    }
    const result = await ImageManipulator.manipulateAsync(
      uri,
      [
        {
          crop: {
            originX,
            originY,
            width: cropWidth,
            height: cropHeight,
          },
        },
      ],
      { compress: 1, format: ImageManipulator.SaveFormat.JPEG }
    );
    return result.uri;
  };

  /**
   * Comprueba y reduce la imagen para que quede por debajo de MAX_FILE_SIZE.
   */
  const ensureUnderMaxSize = async (
    uri: string,
    originalWidth: number,
    originalHeight: number
  ): Promise<string> => {
    let currentUri = uri;
    let width = originalWidth;
    let height = originalHeight;
    const maxPasses = 3;
    let compressQuality = 0.7;
    for (let attempt = 1; attempt <= maxPasses; attempt++) {
      const fileInfo = await FileSystem.getInfoAsync(currentUri);
      if (!fileInfo.exists || typeof fileInfo.size !== 'number') {
        return currentUri;
      }
      if (fileInfo.size <= MAX_FILE_SIZE) {
        return currentUri;
      }
      const ratio = Math.sqrt(MAX_FILE_SIZE / fileInfo.size);
      const newWidth = Math.floor(width * Math.min(ratio, 0.9));
      const newHeight = Math.floor(height * Math.min(ratio, 0.9));
      const manipResult = await ImageManipulator.manipulateAsync(
        currentUri,
        [{ resize: { width: newWidth, height: newHeight } }],
        { compress: compressQuality, format: ImageManipulator.SaveFormat.JPEG }
      );
      currentUri = manipResult.uri;
      width = newWidth;
      height = newHeight;
      compressQuality = Math.max(compressQuality - 0.1, 0.3);
    }
    return currentUri;
  };

  /**
   * Flujo completo: seleccionar imagen, (opcional) recortar, comprimir y retornar el URI.
   */
  const pickAndProcessImage = async (fromCamera: boolean): Promise<string | null> => {
    const result = await pickImageFromSource(fromCamera);
    if (!result || result.canceled === true || (result as any).cancelled === true) {
      return null;
    }
    const asset = result.assets ? result.assets[0] : result;
    if (!asset || !asset.uri || !asset.width || !asset.height) {
      return null;
    }
    let processedUri = asset.uri;
    if (crop) {
      processedUri = await cropImage(processedUri, cropAspect, asset.width, asset.height);
    }
    processedUri = await ensureUnderMaxSize(processedUri, asset.width, asset.height);
    return processedUri;
  };

  /**
   * Maneja la selecciÃ³n de imagen mostrando un Alert para elegir entre cÃ¡mara o galerÃ­a.
   */
  const handleSelectImage = () => {
    Alert.alert(
      'Seleccionar Imagen',
      'Â¿Deseas usar la cÃ¡mara o la galerÃ­a?',
      [
        { text: 'CÃ¡mara', onPress: () => void pickAndUpload(true) },
        { text: 'GalerÃ­a', onPress: () => void pickAndUpload(false) },
        { text: 'Cancelar', style: 'cancel' },
      ],
      { cancelable: true }
    );
  };

  /**
   * Abre la cÃ¡mara o la galerÃ­a, procesa la imagen y la sube al servidor.
   * Se llama a uploadFile con los cuatro parÃ¡metros requeridos.
   */
  const pickAndUpload = async (fromCamera: boolean) => {
    try {
      setLoading(true);
      const newUri = await pickAndProcessImage(fromCamera);
      if (!newUri) {
        setLoading(false);
        return;
      }
      if (!token) {
        Alert.alert('Error', 'No se encontrÃ³ token');
        setLoading(false);
        return;
      }
      // Obtener el tamaÃ±o del archivo para subir
      const fileInfo = await FileSystem.getInfoAsync(newUri);
      const fileSize = fileInfo.exists && fileInfo.size ? fileInfo.size : 0;
      let filename = newUri.split('/').pop() || 'photo.jpg';
      if (!/\.\w+$/.test(filename)) {
        filename = `${filename}.jpg`;
      }
      const match = /\.(\w+)$/.exec(filename);
      const fileType =
        match && match[1].toLowerCase() === 'jpg'
          ? 'image/jpeg'
          : match
          ? `image/${match[1].toLowerCase()}`
          : 'image/jpeg';

      // Llamada a uploadFile con los parÃ¡metros: URI, filename, fileType y fileSize
      const fileData = await uploadFile(newUri, filename, fileType, fileSize);
      if (fileData) {
        setInternalUri(newUri);
        setHasError(false);
        if (onImageChange) {
          onImageChange(fileData.id.toString());
        }
      } else {
        Alert.alert('Error', 'No se pudo subir la imagen');
      }
    } catch (err: any) {
      Alert.alert('Error', err.message);
    } finally {
      setLoading(false);
    }
  };

  const circleStyle = {
    width: size,
    height: size,
    borderRadius: size / 2,
  };

  return (
    <View style={[styles.container, style, circleStyle]}>
      {loading && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator color="#fff" size="large" />
        </View>
      )}
      {internalUri && !hasError ? (
        <Image
          source={{ uri: internalUri }}
          style={[
            styles.image,
            { width: size, height: size, borderRadius: size / 2 },
            loading && { opacity: 0.4 },
          ]}
          resizeMode="cover"
        />
      ) : (
        <View style={[styles.image, styles.placeholder, circleStyle]} />
      )}
      {editable && !loading && (
        <TouchableOpacity style={styles.cameraButton} onPress={handleSelectImage}>
          <Text style={styles.cameraIcon}>ðŸ“·</Text>
        </TouchableOpacity>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignSelf: 'center',
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingOverlay: {
    position: 'absolute',
    zIndex: 2,
  },
  image: {
    // Se define a nivel de props en el <Image>
  },
  placeholder: {
    backgroundColor: 'blue',
  },
  cameraButton: {
    position: 'absolute',
    right: 0,
    bottom: 0,
    width: '30%',
    height: '30%',
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 9999,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 3,
  },
  cameraIcon: {
    color: '#fff',
    fontSize: 32,
  },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: DateTime.tsx
Content:
// @/components/DataTime.tsx
import React, { useState } from 'react';
import { View, Button, Text } from 'react-native';
import DateTimePicker from '@react-native-community/datetimepicker';

function toMySQLDateTime(date: Date): string {
  const pad = (n: number) => (n < 10 ? '0' + n : n);
  const y = date.getFullYear();
  const m = pad(date.getMonth() + 1);
  const d = pad(date.getDate());
  const hh = pad(date.getHours());
  const mm = pad(date.getMinutes());
  const ss = pad(date.getSeconds());
  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
}

// Recibe una prop 'onDateChange' para notificar al padre la fecha elegida
export default function MyDatePicker({
  label,
  onDateChange,
}: {
  label: string;
  onDateChange: (dateString: string) => void;
}) {
  const [date, setDate] = useState(new Date());
  const [show, setShow] = useState(false);

  // Guardamos la cadena MySQL para mostrarla en pantalla
  const [mysqlDate, setMysqlDate] = useState('');

  const onChange = (event: any, selectedDate?: Date) => {
    const currentDate = selectedDate || date;
    setShow(false);
    setDate(currentDate);
    const dateStr = toMySQLDateTime(currentDate);
    setMysqlDate(dateStr);
    onDateChange(dateStr); // <-- Notificamos al padre
  };

  return (
    <View style={{ marginVertical: 10 }}>
      <Text style={{ fontWeight: 'bold', marginBottom: 8 }}>{label}</Text>
      <Button title="Seleccionar Fecha/Hora" onPress={() => setShow(true)} />
      <Text style={{ marginTop: 8 }}>
        {mysqlDate ? `Seleccionado: ${mysqlDate}` : '(Nada aÃºn)'}
      </Text>

      {show && (
        <DateTimePicker
          value={date}
          mode="datetime"
          display="default"
          onChange={onChange}
        />
      )}
    </View>
  );
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: FileCarousel.tsx
Content:
import React, { useState, useEffect, useContext, useRef } from 'react';
import {
  View,
  Text,
  Image,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Modal,
  Dimensions,
  FlatList,
  Linking,
  ActivityIndicator
} from 'react-native';
import Video from 'react-native-video';
import * as DocumentPicker from 'expo-document-picker';
import { FileContext } from '@/contexts/FilesContext';

const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;

interface FileCarouselProps {
  filesJson: string;
  onChangeFilesJson: (updatedJson: string) => void;
}

interface AttachedFile {
  id: number;
  originalName: string;
  fileType: string;
  previewUri: string;
  loading: boolean;
}

interface FileItemProps {
  file: AttachedFile;
  onDelete: (fileId: number) => void;
  onPreview: (index: number) => void;
  index: number;
}

const FileItem: React.FC<FileItemProps> = ({ file, onDelete, onPreview, index }) => {
  if (file.loading) {
    return (
      <View style={[styles.fileItem, styles.loadingContainer]}>        
        <ActivityIndicator />
      </View>
    );
  }

  const lowerType = file.fileType.toLowerCase();
  const isImage = lowerType.includes('image');
  const isVideo = lowerType.includes('video');

  return (
    <TouchableOpacity style={styles.fileItem} onPress={() => onPreview(index)}>
      {isImage ? (
        <Image source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" />
      ) : isVideo ? (
        <Video source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" paused />
      ) : (
        <View style={[styles.media, styles.defaultIcon]}>          
          <Text style={styles.iconText}>{file.originalName}</Text>
        </View>
      )}
      <TouchableOpacity style={styles.deleteButton} onPress={() => onDelete(file.id)}>
        <Text style={styles.deleteButtonText}>Delete</Text>
      </TouchableOpacity>
    </TouchableOpacity>
  );
};

const FileCarousel: React.FC<FileCarouselProps> = ({ filesJson, onChangeFilesJson }) => {
  const { uploadFile, getFile, getFileMetadata } = useContext(FileContext);
  const [attachedFiles, setAttachedFiles] = useState<AttachedFile[]>([]);
  const [previewIndex, setPreviewIndex] = useState<number | null>(null);
  const flatListRef = useRef<FlatList<AttachedFile>>(null);

  useEffect(() => {
    const loadPlaceholders = () => {
      try {
        const ids: number[] = filesJson ? JSON.parse(filesJson) : [];
        const placeholders = ids.map(id => ({ id, previewUri: '', fileType: '', originalName: '', loading: true } as AttachedFile));
        setAttachedFiles(placeholders);

        ids.forEach(async (id, idx) => {
          try {
            const [dataUri, metadata] = await Promise.all([
              getFile(id),
              getFileMetadata(id)
            ]);

            const fileType = metadata?.file_type ?? '';
            const originalName = metadata?.original_name ?? '';

            setAttachedFiles(prev => {
              const copy = [...prev];
              copy[idx] = {
                id,
                previewUri: dataUri || '',
                fileType,
                originalName,
                loading: false
              };
              return copy;
            });
          } catch (e) {
            console.error(`Error loading file ${id}:`, e);
            setAttachedFiles(prev => prev.filter((_, i) => i !== idx));
          }
        });
      } catch (error) {
        console.error('Error parsing filesJson:', error);
        Alert.alert('Error', 'Formato invÃ¡lido en filesJson.');
      }
    };
    loadPlaceholders();
  }, [filesJson, getFile, getFileMetadata]);

  const pickFile = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        copyToCacheDirectory: true,
        multiple: false,
      });
      if (result?.assets && result.assets.length > 0) {
        const asset = result.assets[0];
        return {
          uri: asset.uri,
          name: asset.name,
          type: asset.mimeType ?? 'application/octet-stream',
          size: asset.size ?? 0,
        };
      }
      return null;
    } catch (error) {
      console.error('Error seleccionando documento:', error);
      return null;
    }
  };

  const handleAddFile = async () => {
    try {
      const picked = await pickFile();
      if (!picked) return;
      if (!picked.uri.startsWith('file://')) {
        Alert.alert('Error', 'El URI del archivo no es vÃ¡lido.');
        return;
      }

      const fileData = await uploadFile(picked.uri, picked.name, picked.type, picked.size);
      if (!fileData) {
        Alert.alert('Error', 'No se pudo subir el archivo.');
        return;
      }

      const placeholder: AttachedFile = { id: fileData.id, previewUri: '', fileType: '', originalName: '', loading: true };
      setAttachedFiles(prev => {
        const newArr = [...prev, placeholder];
        onChangeFilesJson(JSON.stringify(newArr.map(f => f.id)));
        return newArr;
      });

      const dataUri = await getFile(fileData.id);
      const metadata = await getFileMetadata(fileData.id);
      const fileType = metadata?.file_type ?? '';
      const originalName = metadata?.original_name ?? '';

      setAttachedFiles(prev =>
        prev.map(f => f.id === fileData.id
          ? { id: f.id, previewUri: dataUri ?? '', fileType, originalName, loading: false }
          : f
        )
      );
    } catch (error: any) {
      console.error('Error agregando archivo:', error);
      Alert.alert('Error', error.message);
    }
  };

  const handleDeleteFile = (id: number) => {
    setAttachedFiles(prev => {
      const filtered = prev.filter(f => f.id !== id);
      onChangeFilesJson(JSON.stringify(filtered.map(f => f.id)));
      return filtered;
    });
  };

  const renderPreviewModal = () => {
    if (previewIndex === null) return null;
    return (
      <Modal visible transparent animationType="fade" onRequestClose={() => setPreviewIndex(null)}>
        <FlatList
          ref={flatListRef}
          data={attachedFiles}
          horizontal
          pagingEnabled
          initialScrollIndex={previewIndex}
          getItemLayout={(_, index) => ({ length: screenWidth, offset: screenWidth * index, index })}
          onScrollToIndexFailed={({ index }) => {
            setTimeout(() => {
              flatListRef.current?.scrollToIndex({ index, animated: true });
            }, 100);
          }}
          keyExtractor={item => item.id.toString()}
          renderItem={({ item }) => {
            const lowerType = item.fileType.toLowerCase();
            const isImage = lowerType.includes('image');
            const isVideo = lowerType.includes('video');
            return (
              <View style={styles.modalContent}>
                {isImage
                  ? <Image source={{ uri: item.previewUri }} style={styles.fullImage} resizeMode="contain" />
                  : isVideo
                    ? <Video source={{ uri: item.previewUri }} style={styles.fullImage} resizeMode="contain" controls />
                    : <Text style={styles.fileNameText}>{item.originalName}</Text>
                }
              </View>
            );
          }}
          style={styles.modalOverlay}
        />
        <View style={styles.modalTopOverlay}>
          <Text style={styles.modalIndex}>{previewIndex + 1} / {attachedFiles.length}</Text>
          <TouchableOpacity style={styles.modalDownloadButton} onPress={() => Linking.openURL(attachedFiles[previewIndex].previewUri)}>
            <Text style={styles.modalDownloadText}>Descargar</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.modalCloseButton} onPress={() => setPreviewIndex(null)}>
            <Text style={styles.modalCloseText}>Cerrar</Text>
          </TouchableOpacity>
        </View>
      </Modal>
    );
  };

  return (
    <>
      <ScrollView
        horizontal
        pagingEnabled
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.carouselContainer}
      >
        {attachedFiles.map((file, idx) => (
          <FileItem
            key={file.id.toString()}
            file={file}
            index={idx}
            onDelete={handleDeleteFile}
            onPreview={setPreviewIndex}
          />
        ))}
        <TouchableOpacity style={[styles.fileItem, styles.addFileItem]} onPress={handleAddFile}>
          <Text style={styles.addButtonText}>Add File</Text>
        </TouchableOpacity>
      </ScrollView>
      {renderPreviewModal()}
    </>
  );
};

export default FileCarousel;

const styles = StyleSheet.create({
  carouselContainer: {
    alignItems: 'center',
    paddingHorizontal: 10,
  },
  fileItem: {
    width: 250,
    height: 200,
    marginHorizontal: 10,
    borderRadius: 8,
    overflow: 'hidden',
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingContainer: {
    backgroundColor: '#ddd',
  },  
  media: {
    width: '100%',
    height: '100%',
  },
  defaultIcon: {
    backgroundColor: '#ccc',
    alignItems: 'center',
    justifyContent: 'center',
  },
  iconText: {
    color: '#555',
    fontSize: 18,
    fontWeight: 'bold',
  },
  deleteButton: {
    position: 'absolute',
    top: 5,
    right: 5,
    backgroundColor: 'rgba(255,0,0,0.7)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 12,
  },
  addFileItem: {
    backgroundColor: '#007bff',
    borderStyle: 'dashed',
    borderWidth: 2,
    borderColor: '#fff',
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.9)',
  },
  modalContent: {
    width: screenWidth,
    height: screenHeight,
    justifyContent: 'center',
    alignItems: 'center',
  },
  fullImage: {
    width: '100%',
    height: '100%',
  },
  fileNameText: {
    color: 'white',
    fontSize: 20,
    textAlign: 'center',
    padding: 20,
  },
  modalTopOverlay: {
    position: 'absolute',
    top: 40,
    left: 20,
    right: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  modalCloseButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalCloseText: {
    color: '#fff',
    fontSize: 16,
  },
  modalIndex: {
    color: '#fff',
    fontSize: 16,
  },
  modalDownloadButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalDownloadText: {
    color: '#fff',
    fontSize: 16,
  },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: FilePreviewModal.tsx
Content:
// FileCarousel.tsx (con modal swipe, indicador de posiciÃ³n y botÃ³n de descarga)
import React, { useState, useEffect, useContext, useRef } from 'react';
import {
  View,
  Text,
  Image,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Modal,
  Dimensions,
  FlatList,
  Linking,
} from 'react-native';
import Video from 'react-native-video';
import * as DocumentPicker from 'expo-document-picker';
import { FileContext } from '@/contexts/FilesContext';
import ImageViewing from 'react-native-image-viewing';

const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;

interface FileCarouselProps {
  filesJson: string;
  onChangeFilesJson: (updatedJson: string) => void;
}

interface AttachedFile {
  id: number;
  originalName?: string;
  fileType?: string;
  previewUri: string;
}

interface FileItemProps {
  file: AttachedFile;
  onDelete: (fileId: number) => void;
  onPreview: (index: number) => void;
  index: number;
}

const FileItem: React.FC<FileItemProps> = ({ file, onDelete, onPreview, index }) => {
  const renderFilePreview = () => {
    if (file.fileType) {
      const lowerType = file.fileType.toLowerCase();
      if (lowerType.includes('image')) {
        return <Image source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" />;
      } else if (lowerType.includes('video')) {
        return <Video source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" paused />;
      }
    }
    return (
      <View style={[styles.media, styles.defaultIcon]}>
        <Text style={styles.iconText}>{file.originalName || 'FILE'}</Text>
      </View>
    );
  };

  return (
    <TouchableOpacity style={styles.fileItem} onPress={() => onPreview(index)}>
      {renderFilePreview()}
      <TouchableOpacity style={styles.deleteButton} onPress={() => onDelete(file.id)}>
        <Text style={styles.deleteButtonText}>Delete</Text>
      </TouchableOpacity>
    </TouchableOpacity>
  );
};

const FileCarousel: React.FC<FileCarouselProps> = ({ filesJson, onChangeFilesJson }) => {
  const { uploadFile, getFile } = useContext(FileContext);
  const [attachedFiles, setAttachedFiles] = useState<AttachedFile[]>([]);
  const [previewIndex, setPreviewIndex] = useState<number | null>(null);
  const flatListRef = useRef<FlatList>(null);

  useEffect(() => {
    const fetchFiles = async () => {
      try {
        const fileIds: number[] = filesJson ? JSON.parse(filesJson) : [];
        const files: AttachedFile[] = [];

        for (const id of fileIds) {
          const dataUri = await getFile(id);
          if (dataUri) {
            files.push({ id, previewUri: dataUri });
          } else {
            console.warn(`Archivo ${id} no encontrado.`);
          }
        }

        setAttachedFiles(files);
      } catch (error) {
        console.error('Error parsing filesJson:', error);
        Alert.alert('Error', 'Formato invÃ¡lido en filesJson.');
      }
    };

    fetchFiles();
  }, [filesJson, getFile]);

  const pickFile = async (): Promise<{ uri: string; name: string; type: string; size: number } | null> => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        copyToCacheDirectory: true,
        multiple: false,
      });

      if (result?.assets && result.assets.length > 0) {
        const asset = result.assets[0];
        return {
          uri: asset.uri,
          name: asset.name,
          type: asset.mimeType || 'application/octet-stream',
          size: asset.size || 0,
        };
      }

      return null;
    } catch (error) {
      console.error('Error seleccionando documento:', error);
      return null;
    }
  };

  const handleAddFile = async () => {
    try {
      const pickedFile = await pickFile();
      if (!pickedFile) return;

      if (!pickedFile.uri.startsWith('file://')) {
        Alert.alert('Error', 'El URI del archivo no es vÃ¡lido.');
        return;
      }

      const fileData = await uploadFile(pickedFile.uri, pickedFile.name, pickedFile.type, pickedFile.size);
      if (!fileData) {
        Alert.alert('Error', 'No se pudo subir el archivo.');
        return;
      }

      const previewUri = await getFile(fileData.id);

      const newFile: AttachedFile = {
        id: fileData.id,
        originalName: fileData.original_name,
        fileType: fileData.file_type,
        previewUri: previewUri || '',
      };

      const updatedFiles = [...attachedFiles, newFile];
      setAttachedFiles(updatedFiles);
      onChangeFilesJson(JSON.stringify(updatedFiles.map((file) => file.id)));
    } catch (error: any) {
      console.error('Error agregando archivo:', error);
      Alert.alert('Error', error.message);
    }
  };

  const handleDeleteFile = (fileId: number) => {
    const updatedFiles = attachedFiles.filter(file => file.id !== fileId);
    setAttachedFiles(updatedFiles);
    onChangeFilesJson(JSON.stringify(updatedFiles.map(file => file.id)));
  };

  const renderPreviewModal = () => {
    if (previewIndex === null) return null;
  
    const isImage = attachedFiles[previewIndex]?.fileType?.toLowerCase().includes('image');
  
    if (isImage) {
      const imageSources = attachedFiles.map(f => ({ uri: f.previewUri }));
  
      return (
        <ImageViewing
          images={imageSources}
          imageIndex={previewIndex}
          visible={true}
          onRequestClose={() => setPreviewIndex(null)}
          FooterComponent={({ imageIndex }) => (
            <View style={styles.modalTopOverlay}>
              <Text style={styles.modalIndex}>{imageIndex + 1} / {attachedFiles.length}</Text>
              {/*<TouchableOpacity
                style={styles.modalDownloadButton}
                onPress={() => Linking.openURL(attachedFiles[imageIndex].previewUri)}
              >
                <Text style={styles.modalDownloadText}>Descargar</Text>
              </TouchableOpacity>*/}
              <TouchableOpacity
                style={styles.modalCloseButton}
                onPress={() => setPreviewIndex(null)}
              >
                <Text style={styles.modalCloseText}>Cerrar</Text>
              </TouchableOpacity>
            </View>
          )}
        />
      );
    }
  
    // Si no es imagen, usamos el modal tradicional
    const renderItem = ({ item }: { item: AttachedFile }) => {
      const lowerType = item.fileType?.toLowerCase() || '';
      const isVideo = lowerType.includes('video');
  
      return (
        <View style={styles.modalContent}>
          {isVideo ? (
            <Video source={{ uri: item.previewUri }} style={styles.fullImage} resizeMode="contain" controls />
          ) : (
            <Text style={styles.fileNameText}>{item.originalName}</Text>
          )}
        </View>
      );
    };
  
    return (
      <Modal visible transparent animationType="fade" onRequestClose={() => setPreviewIndex(null)}>
        <FlatList
          ref={flatListRef}
          data={attachedFiles}
          horizontal
          pagingEnabled
          initialScrollIndex={previewIndex}
          keyExtractor={(item) => item.id.toString()}
          renderItem={renderItem}
          style={styles.modalOverlay}
          onMomentumScrollEnd={(e) => {
            const index = Math.round(e.nativeEvent.contentOffset.x / screenWidth);
            setPreviewIndex(index);
          }}
        />
        <View style={styles.modalTopOverlay}>
          <Text style={styles.modalIndex}>{previewIndex + 1} / {attachedFiles.length}</Text>
          <TouchableOpacity
            style={styles.modalDownloadButton}
            onPress={() => Linking.openURL(attachedFiles[previewIndex].previewUri)}
          >
            <Text style={styles.modalDownloadText}>Descargar</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.modalCloseButton} onPress={() => setPreviewIndex(null)}>
            <Text style={styles.modalCloseText}>Cerrar</Text>
          </TouchableOpacity>
        </View>
      </Modal>
    );
  };
  

  return (
    <>
      <ScrollView
        horizontal
        pagingEnabled
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.carouselContainer}
      >
        {attachedFiles.map((file, index) => (
          <FileItem
            key={file.id.toString()}
            file={file}
            index={index}
            onDelete={handleDeleteFile}
            onPreview={setPreviewIndex}
          />
        ))}
        <TouchableOpacity style={[styles.fileItem, styles.addFileItem]} onPress={handleAddFile}>
          <Text style={styles.addButtonText}>Add File</Text>
        </TouchableOpacity>
      </ScrollView>
      {renderPreviewModal()}
    </>
  );
};

export default FileCarousel;

const styles = StyleSheet.create({
  carouselContainer: {
    alignItems: 'center',
    paddingHorizontal: 10,
  },
  fileItem: {
    width: 250,
    height: 200,
    marginHorizontal: 10,
    borderRadius: 8,
    overflow: 'hidden',
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  media: {
    width: '100%',
    height: '100%',
  },
  defaultIcon: {
    backgroundColor: '#ccc',
    alignItems: 'center',
    justifyContent: 'center',
  },
  iconText: {
    color: '#555',
    fontSize: 18,
    fontWeight: 'bold',
  },
  deleteButton: {
    position: 'absolute',
    top: 5,
    right: 5,
    backgroundColor: 'rgba(255,0,0,0.7)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 12,
  },
  addFileItem: {
    backgroundColor: '#007bff',
    borderStyle: 'dashed',
    borderWidth: 2,
    borderColor: '#fff',
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.9)',
  },
  modalContent: {
    width: screenWidth,
    height: screenHeight,
    justifyContent: 'center',
    alignItems: 'center',
  },
  fullImage: {
    width: '100%',
    height: '100%',
  },
  fileNameText: {
    color: 'white',
    fontSize: 20,
    textAlign: 'center',
    padding: 20,
  },
  modalTopOverlay: {
    position: 'absolute',
    top: 40,
    left: 20,
    right: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  modalCloseButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalCloseText: {
    color: '#fff',
    fontSize: 16,
  },
  modalIndex: {
    color: '#fff',
    fontSize: 16,
  },
  modalDownloadButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalDownloadText: {
    color: '#fff',
    fontSize: 16,
  },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: ModalPicker.tsx
Content:
// app/components/ModalPicker.tsx
import React, { useState, useMemo } from 'react';
import {
  Modal,
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  FlatList,
  Image,
} from 'react-native';

export interface ModalPickerItem {
  id: number | string;
  name: string;
  imageFileId?: string | null; // URL o ruta de la imagen (opcional)
  backgroundColor?: string;    // Color de fondo para el Ã­tem (opcional)
}

interface ModalPickerProps {
  items: ModalPickerItem[];
  selectedItem?: ModalPickerItem | null;
  onSelect: (item: ModalPickerItem) => void;
  placeholder?: string;
}

export const ModalPicker: React.FC<ModalPickerProps> = ({
  items,
  selectedItem = null,
  onSelect,
  placeholder = "Selecciona un Ã­tem",
}) => {
  const [modalVisible, setModalVisible] = useState(false);

  // Si se pasa el objeto completo se usa; si no, se intenta hallar a partir de selectedValue (si fuera necesario)
  const computedSelectedItem = useMemo(() => {
    return selectedItem;
  }, [selectedItem]);

  const handleSelect = (item: ModalPickerItem) => {
    onSelect(item);
    setModalVisible(false);
  };

  return (
    <View>
      {/* BotÃ³n que muestra el elemento seleccionado (con el fondo coloreado si aplica) o el placeholder */}
      <TouchableOpacity
        style={[
          styles.selectorButton,
          computedSelectedItem && computedSelectedItem.backgroundColor
            ? { backgroundColor: computedSelectedItem.backgroundColor }
            : {},
        ]}
        onPress={() => setModalVisible(true)}
      >
        {computedSelectedItem ? (
          <Text
            style={[
              styles.selectorText,
              computedSelectedItem.backgroundColor ? { color: '#fff' } : {},
            ]}
          >
            {computedSelectedItem.name}
          </Text>
        ) : (
          <Text style={styles.placeholderText}>{placeholder}</Text>
        )}
      </TouchableOpacity>

      {/* Modal con la lista de opciones */}
      <Modal visible={modalVisible} animationType="slide" transparent={true}>
        <TouchableOpacity
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setModalVisible(false)}
        >
          <View style={styles.modalContainer}>
            <FlatList
              data={items}
              keyExtractor={(item) => item.id.toString()}
              renderItem={({ item }) => (
                <TouchableOpacity
                  style={[
                    styles.itemContainer,
                    { backgroundColor: item.backgroundColor || "#fff" },
                  ]}
                  onPress={() => handleSelect(item)}
                >
                  {item.imageFileId && (
                    <Image
                      source={{ uri: item.imageFileId }}
                      style={styles.itemImage}
                    />
                  )}
                  <Text
                    style={[
                      styles.itemText,
                      item.backgroundColor ? { color: '#fff' } : {},
                    ]}
                  >
                    {item.name}
                  </Text>
                </TouchableOpacity>
              )}
            />
          </View>
        </TouchableOpacity>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  selectorButton: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    padding: 12,
  },
  selectorText: {
    fontSize: 16,
  },
  placeholderText: {
    fontSize: 16,
    color: '#999',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: '#000000aa',
    justifyContent: 'center',
    padding: 20,
  },
  modalContainer: {
    backgroundColor: '#fff',
    borderRadius: 10,
    maxHeight: '80%',
  },
  itemContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderBottomColor: '#ccc',
    borderBottomWidth: 1,
  },
  itemImage: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: 10,
  },
  itemText: {
    fontSize: 16,
  },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: output.txt
Content:
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: CircleImagePicker.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/components/CircleImagePicker.tsx

import React, { useState, useEffect, useContext } from 'react';
import {
  View,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Image,
  ActivityIndicator,
  Text,
  StyleProp,
  ViewStyle,
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import * as FileSystem from 'expo-file-system';
import { MAX_FILE_SIZE } from '@/config/Index';
import { AuthContext } from '@/contexts/AuthContext';
import { FileContext } from '@/contexts/FilesContext';

/**
 * Props del componente CircleImagePicker.
 */
interface CircleImagePickerProps {
  /**
   * ID de archivo en el servidor. Si se proporciona, se descargarÃƒÂ¡ la imagen.
   */
  fileId?: string | null;
  /**
   * URI local (o remota) a usar directamente.
   * Tiene prioridad sobre fileId.
   */
  imageUri?: string | null;
  /**
   * Indica si se muestra el ÃƒÂ­cono de cÃƒÂ¡mara para cambiar la imagen.
   */
  editable?: boolean;
  /**
   * TamaÃƒÂ±o (ancho/alto) del cÃƒÂ­rculo.
   */
  size?: number;
  /**
   * Callback que se dispara cuando se sube con ÃƒÂ©xito una nueva imagen
   * y se obtiene un nuevo fileId del servidor.
   */
  onImageChange?: (newFileId: string) => void;
  /**
   * Indica si se debe recortar la imagen tras seleccionarla.
   */
  crop?: boolean;
  /**
   * RazÃƒÂ³n de aspecto para el recorte (por ejemplo, 1 para 1:1).
   * Si no se especifica, se usa 1 (cuadrado).
   */
  cropAspect?: number;
  /**
   * Estilo adicional para el contenedor principal.
   */
  style?: StyleProp<ViewStyle>;
}

export default function CircleImagePicker({
  fileId = null,
  imageUri = null,
  editable = false,
  size = 80,
  crop = false,
  cropAspect = 1,
  onImageChange,
  style,
}: CircleImagePickerProps): JSX.Element {
  const [loading, setLoading] = useState<boolean>(false);
  const [internalUri, setInternalUri] = useState<string | null>(null);
  const [hasError, setHasError] = useState<boolean>(false);
  const { token } = useContext(AuthContext);
  // Se importan las funciones del contexto FileContext
  const { uploadFile, getFile } = useContext(FileContext);

  // Cargar la imagen segÃƒÂºn imageUri o fileId
  useEffect(() => {
    if (imageUri) {
      setInternalUri(imageUri);
      setHasError(false);
    } else if (fileId) {
      void loadFileFromServer(fileId);
    } else {
      setInternalUri(null);
      setHasError(false);
    }
  }, [fileId, imageUri]);

  /**
   * Descarga la imagen desde el servidor usando un fileId.
   */
  const loadFileFromServer = async (fId: string) => {
    try {
      setLoading(true);
      setHasError(false);
      if (!token) {
        setHasError(true);
        setLoading(false);
        return;
      }
      // Usamos getFile del contexto, que maneja la cachÃƒÂ©
      const uri = await getFile(parseInt(fId));
      if (uri) {
        setInternalUri(uri);
        setHasError(false);
      } else {
        setHasError(true);
      }
      setLoading(false);
     
    } catch (error) {
      setHasError(true);
      setLoading(false);
    }
  };

  /**
   * Solicita permisos y abre la fuente de imagen (cÃƒÂ¡mara o galerÃƒÂ­a).
   */
  const pickImageFromSource = async (fromCamera: boolean) => {
    if (fromCamera) {
      const { status } = await ImagePicker.requestCameraPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permiso denegado', 'Se requieren permisos de cÃƒÂ¡mara.');
        return null;
      }
      return await ImagePicker.launchCameraAsync({ quality: 0.7 });
    } else {
      const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permiso denegado', 'Se requieren permisos de galerÃƒÂ­a.');
        return null;
      }
      return await ImagePicker.launchImageLibraryAsync({ quality: 0.7 });
    }
  };

  /**
   * Recorta la imagen de forma centrada segÃƒÂºn el aspecto deseado.
   */
  const cropImage = async (
    uri: string,
    aspect: number,
    width: number,
    height: number
  ): Promise<string> => {
    let cropWidth = width;
    let cropHeight = height;
    let originX = 0;
    let originY = 0;
    const currentRatio = width / height;
    if (currentRatio > aspect) {
      cropWidth = height * aspect;
      originX = (width - cropWidth) / 2;
    } else {
      cropHeight = width / aspect;
      originY = (height - cropHeight) / 2;
    }
    const result = await ImageManipulator.manipulateAsync(
      uri,
      [
        {
          crop: {
            originX,
            originY,
            width: cropWidth,
            height: cropHeight,
          },
        },
      ],
      { compress: 1, format: ImageManipulator.SaveFormat.JPEG }
    );
    return result.uri;
  };

  /**
   * Comprueba y reduce la imagen para que quede por debajo de MAX_FILE_SIZE.
   */
  const ensureUnderMaxSize = async (
    uri: string,
    originalWidth: number,
    originalHeight: number
  ): Promise<string> => {
    let currentUri = uri;
    let width = originalWidth;
    let height = originalHeight;
    const maxPasses = 3;
    let compressQuality = 0.7;
    for (let attempt = 1; attempt <= maxPasses; attempt++) {
      const fileInfo = await FileSystem.getInfoAsync(currentUri);
      if (!fileInfo.exists || typeof fileInfo.size !== 'number') {
        return currentUri;
      }
      if (fileInfo.size <= MAX_FILE_SIZE) {
        return currentUri;
      }
      const ratio = Math.sqrt(MAX_FILE_SIZE / fileInfo.size);
      const newWidth = Math.floor(width * Math.min(ratio, 0.9));
      const newHeight = Math.floor(height * Math.min(ratio, 0.9));
      const manipResult = await ImageManipulator.manipulateAsync(
        currentUri,
        [{ resize: { width: newWidth, height: newHeight } }],
        { compress: compressQuality, format: ImageManipulator.SaveFormat.JPEG }
      );
      currentUri = manipResult.uri;
      width = newWidth;
      height = newHeight;
      compressQuality = Math.max(compressQuality - 0.1, 0.3);
    }
    return currentUri;
  };

  /**
   * Flujo completo: seleccionar imagen, (opcional) recortar, comprimir y retornar el URI.
   */
  const pickAndProcessImage = async (fromCamera: boolean): Promise<string | null> => {
    const result = await pickImageFromSource(fromCamera);
    if (!result || result.canceled === true || (result as any).cancelled === true) {
      return null;
    }
    const asset = result.assets ? result.assets[0] : result;
    if (!asset || !asset.uri || !asset.width || !asset.height) {
      return null;
    }
    let processedUri = asset.uri;
    if (crop) {
      processedUri = await cropImage(processedUri, cropAspect, asset.width, asset.height);
    }
    processedUri = await ensureUnderMaxSize(processedUri, asset.width, asset.height);
    return processedUri;
  };

  /**
   * Maneja la selecciÃƒÂ³n de imagen mostrando un Alert para elegir entre cÃƒÂ¡mara o galerÃƒÂ­a.
   */
  const handleSelectImage = () => {
    Alert.alert(
      'Seleccionar Imagen',
      'Ã‚Â¿Deseas usar la cÃƒÂ¡mara o la galerÃƒÂ­a?',
      [
        { text: 'CÃƒÂ¡mara', onPress: () => void pickAndUpload(true) },
        { text: 'GalerÃƒÂ­a', onPress: () => void pickAndUpload(false) },
        { text: 'Cancelar', style: 'cancel' },
      ],
      { cancelable: true }
    );
  };

  /**
   * Abre la cÃƒÂ¡mara o la galerÃƒÂ­a, procesa la imagen y la sube al servidor.
   * Se llama a uploadFile con los cuatro parÃƒÂ¡metros requeridos.
   */
  const pickAndUpload = async (fromCamera: boolean) => {
    try {
      setLoading(true);
      const newUri = await pickAndProcessImage(fromCamera);
      if (!newUri) {
        setLoading(false);
        return;
      }
      if (!token) {
        Alert.alert('Error', 'No se encontrÃƒÂ³ token');
        setLoading(false);
        return;
      }
      // Obtener el tamaÃƒÂ±o del archivo para subir
      const fileInfo = await FileSystem.getInfoAsync(newUri);
      const fileSize = fileInfo.exists && fileInfo.size ? fileInfo.size : 0;
      let filename = newUri.split('/').pop() || 'photo.jpg';
      if (!/\.\w+$/.test(filename)) {
        filename = `${filename}.jpg`;
      }
      const match = /\.(\w+)$/.exec(filename);
      const fileType =
        match && match[1].toLowerCase() === 'jpg'
          ? 'image/jpeg'
          : match
          ? `image/${match[1].toLowerCase()}`
          : 'image/jpeg';

      // Llamada a uploadFile con los parÃƒÂ¡metros: URI, filename, fileType y fileSize
      const fileData = await uploadFile(newUri, filename, fileType, fileSize);
      if (fileData) {
        setInternalUri(newUri);
        setHasError(false);
        if (onImageChange) {
          onImageChange(fileData.id.toString());
        }
      } else {
        Alert.alert('Error', 'No se pudo subir la imagen');
      }
    } catch (err: any) {
      Alert.alert('Error', err.message);
    } finally {
      setLoading(false);
    }
  };

  const circleStyle = {
    width: size,
    height: size,
    borderRadius: size / 2,
  };

  return (
    <View style={[styles.container, style, circleStyle]}>
      {loading && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator color="#fff" size="large" />
        </View>
      )}
      {internalUri && !hasError ? (
        <Image
          source={{ uri: internalUri }}
          style={[
            styles.image,
            { width: size, height: size, borderRadius: size / 2 },
            loading && { opacity: 0.4 },
          ]}
          resizeMode="cover"
        />
      ) : (
        <View style={[styles.image, styles.placeholder, circleStyle]} />
      )}
      {editable && !loading && (
        <TouchableOpacity style={styles.cameraButton} onPress={handleSelectImage}>
          <Text style={styles.cameraIcon}>Ã°Å¸â€œÂ·</Text>
        </TouchableOpacity>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignSelf: 'center',
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingOverlay: {
    position: 'absolute',
    zIndex: 2,
  },
  image: {
    // Se define a nivel de props en el <Image>
  },
  placeholder: {
    backgroundColor: 'blue',
  },
  cameraButton: {
    position: 'absolute',
    right: 0,
    bottom: 0,
    width: '30%',
    height: '30%',
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 9999,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 3,
  },
  cameraIcon: {
    color: '#fff',
    fontSize: 32,
  },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: DateTime.tsx
Content:
// @/components/DataTime.tsx
import React, { useState } from 'react';
import { View, Button, Text } from 'react-native';
import DateTimePicker from '@react-native-community/datetimepicker';

function toMySQLDateTime(date: Date): string {
  const pad = (n: number) => (n < 10 ? '0' + n : n);
  const y = date.getFullYear();
  const m = pad(date.getMonth() + 1);
  const d = pad(date.getDate());
  const hh = pad(date.getHours());
  const mm = pad(date.getMinutes());
  const ss = pad(date.getSeconds());
  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
}

// Recibe una prop 'onDateChange' para notificar al padre la fecha elegida
export default function MyDatePicker({
  label,
  onDateChange,
}: {
  label: string;
  onDateChange: (dateString: string) => void;
}) {
  const [date, setDate] = useState(new Date());
  const [show, setShow] = useState(false);

  // Guardamos la cadena MySQL para mostrarla en pantalla
  const [mysqlDate, setMysqlDate] = useState('');

  const onChange = (event: any, selectedDate?: Date) => {
    const currentDate = selectedDate || date;
    setShow(false);
    setDate(currentDate);
    const dateStr = toMySQLDateTime(currentDate);
    setMysqlDate(dateStr);
    onDateChange(dateStr); // <-- Notificamos al padre
  };

  return (
    <View style={{ marginVertical: 10 }}>
      <Text style={{ fontWeight: 'bold', marginBottom: 8 }}>{label}</Text>
      <Button title="Seleccionar Fecha/Hora" onPress={() => setShow(true)} />
      <Text style={{ marginTop: 8 }}>
        {mysqlDate ? `Seleccionado: ${mysqlDate}` : '(Nada aÃƒÂºn)'}
      </Text>

      {show && (
        <DateTimePicker
          value={date}
          mode="datetime"
          display="default"
          onChange={onChange}
        />
      )}
    </View>
  );
}

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: FileCarousel.tsx
Content:
import React, { useState, useEffect, useContext, useRef } from 'react';
import {
  View,
  Text,
  Image,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Modal,
  Dimensions,
  FlatList,
  Linking,
  ActivityIndicator
} from 'react-native';
import Video from 'react-native-video';
import * as DocumentPicker from 'expo-document-picker';
import { FileContext } from '@/contexts/FilesContext';

const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;

interface FileCarouselProps {
  filesJson: string;
  onChangeFilesJson: (updatedJson: string) => void;
}

interface AttachedFile {
  id: number;
  originalName: string;
  fileType: string;
  previewUri: string;
  loading: boolean;
}

interface FileItemProps {
  file: AttachedFile;
  onDelete: (fileId: number) => void;
  onPreview: (index: number) => void;
  index: number;
}

const FileItem: React.FC<FileItemProps> = ({ file, onDelete, onPreview, index }) => {
  if (file.loading) {
    return (
      <View style={[styles.fileItem, styles.loadingContainer]}>        
        <ActivityIndicator />
      </View>
    );
  }

  const lowerType = file.fileType.toLowerCase();
  const isImage = lowerType.includes('image');
  const isVideo = lowerType.includes('video');

  return (
    <TouchableOpacity style={styles.fileItem} onPress={() => onPreview(index)}>
      {isImage ? (
        <Image source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" />
      ) : isVideo ? (
        <Video source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" paused />
      ) : (
        <View style={[styles.media, styles.defaultIcon]}>          
          <Text style={styles.iconText}>{file.originalName}</Text>
        </View>
      )}
      <TouchableOpacity style={styles.deleteButton} onPress={() => onDelete(file.id)}>
        <Text style={styles.deleteButtonText}>Delete</Text>
      </TouchableOpacity>
    </TouchableOpacity>
  );
};

const FileCarousel: React.FC<FileCarouselProps> = ({ filesJson, onChangeFilesJson }) => {
  const { uploadFile, getFile, getFileMetadata } = useContext(FileContext);
  const [attachedFiles, setAttachedFiles] = useState<AttachedFile[]>([]);
  const [previewIndex, setPreviewIndex] = useState<number | null>(null);
  const flatListRef = useRef<FlatList<AttachedFile>>(null);

  useEffect(() => {
    const loadPlaceholders = () => {
      try {
        const ids: number[] = filesJson ? JSON.parse(filesJson) : [];
        const placeholders = ids.map(id => ({ id, previewUri: '', fileType: '', originalName: '', loading: true } as AttachedFile));
        setAttachedFiles(placeholders);

        ids.forEach(async (id, idx) => {
          try {
            const [dataUri, metadata] = await Promise.all([
              getFile(id),
              getFileMetadata(id)
            ]);

            const fileType = metadata?.file_type ?? '';
            const originalName = metadata?.original_name ?? '';

            setAttachedFiles(prev => {
              const copy = [...prev];
              copy[idx] = {
                id,
                previewUri: dataUri || '',
                fileType,
                originalName,
                loading: false
              };
              return copy;
            });
          } catch (e) {
            console.error(`Error loading file ${id}:`, e);
            setAttachedFiles(prev => prev.filter((_, i) => i !== idx));
          }
        });
      } catch (error) {
        console.error('Error parsing filesJson:', error);
        Alert.alert('Error', 'Formato invÃƒÂ¡lido en filesJson.');
      }
    };
    loadPlaceholders();
  }, [filesJson, getFile, getFileMetadata]);

  const pickFile = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        copyToCacheDirectory: true,
        multiple: false,
      });
      if (result?.assets && result.assets.length > 0) {
        const asset = result.assets[0];
        return {
          uri: asset.uri,
          name: asset.name,
          type: asset.mimeType ?? 'application/octet-stream',
          size: asset.size ?? 0,
        };
      }
      return null;
    } catch (error) {
      console.error('Error seleccionando documento:', error);
      return null;
    }
  };

  const handleAddFile = async () => {
    try {
      const picked = await pickFile();
      if (!picked) return;
      if (!picked.uri.startsWith('file://')) {
        Alert.alert('Error', 'El URI del archivo no es vÃƒÂ¡lido.');
        return;
      }

      const fileData = await uploadFile(picked.uri, picked.name, picked.type, picked.size);
      if (!fileData) {
        Alert.alert('Error', 'No se pudo subir el archivo.');
        return;
      }

      const placeholder: AttachedFile = { id: fileData.id, previewUri: '', fileType: '', originalName: '', loading: true };
      setAttachedFiles(prev => {
        const newArr = [...prev, placeholder];
        onChangeFilesJson(JSON.stringify(newArr.map(f => f.id)));
        return newArr;
      });

      const dataUri = await getFile(fileData.id);
      const metadata = await getFileMetadata(fileData.id);
      const fileType = metadata?.file_type ?? '';
      const originalName = metadata?.original_name ?? '';

      setAttachedFiles(prev =>
        prev.map(f => f.id === fileData.id
          ? { id: f.id, previewUri: dataUri ?? '', fileType, originalName, loading: false }
          : f
        )
      );
    } catch (error: any) {
      console.error('Error agregando archivo:', error);
      Alert.alert('Error', error.message);
    }
  };

  const handleDeleteFile = (id: number) => {
    setAttachedFiles(prev => {
      const filtered = prev.filter(f => f.id !== id);
      onChangeFilesJson(JSON.stringify(filtered.map(f => f.id)));
      return filtered;
    });
  };

  const renderPreviewModal = () => {
    if (previewIndex === null) return null;
    return (
      <Modal visible transparent animationType="fade" onRequestClose={() => setPreviewIndex(null)}>
        <FlatList
          ref={flatListRef}
          data={attachedFiles}
          horizontal
          pagingEnabled
          initialScrollIndex={previewIndex}
          getItemLayout={(_, index) => ({ length: screenWidth, offset: screenWidth * index, index })}
          onScrollToIndexFailed={({ index }) => {
            setTimeout(() => {
              flatListRef.current?.scrollToIndex({ index, animated: true });
            }, 100);
          }}
          keyExtractor={item => item.id.toString()}
          renderItem={({ item }) => {
            const lowerType = item.fileType.toLowerCase();
            const isImage = lowerType.includes('image');
            const isVideo = lowerType.includes('video');
            return (
              <View style={styles.modalContent}>
                {isImage
                  ? <Image source={{ uri: item.previewUri }} style={styles.fullImage} resizeMode="contain" />
                  : isVideo
                    ? <Video source={{ uri: item.previewUri }} style={styles.fullImage} resizeMode="contain" controls />
                    : <Text style={styles.fileNameText}>{item.originalName}</Text>
                }
              </View>
            );
          }}
          style={styles.modalOverlay}
        />
        <View style={styles.modalTopOverlay}>
          <Text style={styles.modalIndex}>{previewIndex + 1} / {attachedFiles.length}</Text>
          <TouchableOpacity style={styles.modalDownloadButton} onPress={() => Linking.openURL(attachedFiles[previewIndex].previewUri)}>
            <Text style={styles.modalDownloadText}>Descargar</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.modalCloseButton} onPress={() => setPreviewIndex(null)}>
            <Text style={styles.modalCloseText}>Cerrar</Text>
          </TouchableOpacity>
        </View>
      </Modal>
    );
  };

  return (
    <>
      <ScrollView
        horizontal
        pagingEnabled
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.carouselContainer}
      >
        {attachedFiles.map((file, idx) => (
          <FileItem
            key={file.id.toString()}
            file={file}
            index={idx}
            onDelete={handleDeleteFile}
            onPreview={setPreviewIndex}
          />
        ))}
        <TouchableOpacity style={[styles.fileItem, styles.addFileItem]} onPress={handleAddFile}>
          <Text style={styles.addButtonText}>Add File</Text>
        </TouchableOpacity>
      </ScrollView>
      {renderPreviewModal()}
    </>
  );
};

export default FileCarousel;

const styles = StyleSheet.create({
  carouselContainer: {
    alignItems: 'center',
    paddingHorizontal: 10,
  },
  fileItem: {
    width: 250,
    height: 200,
    marginHorizontal: 10,
    borderRadius: 8,
    overflow: 'hidden',
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingContainer: {
    backgroundColor: '#ddd',
  },  
  media: {
    width: '100%',
    height: '100%',
  },
  defaultIcon: {
    backgroundColor: '#ccc',
    alignItems: 'center',
    justifyContent: 'center',
  },
  iconText: {
    color: '#555',
    fontSize: 18,
    fontWeight: 'bold',
  },
  deleteButton: {
    position: 'absolute',
    top: 5,
    right: 5,
    backgroundColor: 'rgba(255,0,0,0.7)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 12,
  },
  addFileItem: {
    backgroundColor: '#007bff',
    borderStyle: 'dashed',
    borderWidth: 2,
    borderColor: '#fff',
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.9)',
  },
  modalContent: {
    width: screenWidth,
    height: screenHeight,
    justifyContent: 'center',
    alignItems: 'center',
  },
  fullImage: {
    width: '100%',
    height: '100%',
  },
  fileNameText: {
    color: 'white',
    fontSize: 20,
    textAlign: 'center',
    padding: 20,
  },
  modalTopOverlay: {
    position: 'absolute',
    top: 40,
    left: 20,
    right: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  modalCloseButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalCloseText: {
    color: '#fff',
    fontSize: 16,
  },
  modalIndex: {
    color: '#fff',
    fontSize: 16,
  },
  modalDownloadButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalDownloadText: {
    color: '#fff',
    fontSize: 16,
  },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/components
File: FilePreviewModal.tsx
Content:
// FileCarousel.tsx (con modal swipe, indicador de posiciÃƒÂ³n y botÃƒÂ³n de descarga)
import React, { useState, useEffect, useContext, useRef } from 'react';
import {
  View,
  Text,
  Image,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Modal,
  Dimensions,
  FlatList,
  Linking,
} from 'react-native';
import Video from 'react-native-video';
import * as DocumentPicker from 'expo-document-picker';
import { FileContext } from '@/contexts/FilesContext';
import ImageViewing from 'react-native-image-viewing';

const screenWidth = Dimensions.get('window').width;
const screenHeight = Dimensions.get('window').height;

interface FileCarouselProps {
  filesJson: string;
  onChangeFilesJson: (updatedJson: string) => void;
}

interface AttachedFile {
  id: number;
  originalName?: string;
  fileType?: string;
  previewUri: string;
}

interface FileItemProps {
  file: AttachedFile;
  onDelete: (fileId: number) => void;
  onPreview: (index: number) => void;
  index: number;
}

const FileItem: React.FC<FileItemProps> = ({ file, onDelete, onPreview, index }) => {
  const renderFilePreview = () => {
    if (file.fileType) {
      const lowerType = file.fileType.toLowerCase();
      if (lowerType.includes('image')) {
        return <Image source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" />;
      } else if (lowerType.includes('video')) {
        return <Video source={{ uri: file.previewUri }} style={styles.media} resizeMode="cover" paused />;
      }
    }
    return (
      <View style={[styles.media, styles.defaultIcon]}>
        <Text style={styles.iconText}>{file.originalName || 'FILE'}</Text>
      </View>
    );
  };

  return (
    <TouchableOpacity style={styles.fileItem} onPress={() => onPreview(index)}>
      {renderFilePreview()}
      <TouchableOpacity style={styles.deleteButton} onPress={() => onDelete(file.id)}>
        <Text style={styles.deleteButtonText}>Delete</Text>
      </TouchableOpacity>
    </TouchableOpacity>
  );
};

const FileCarousel: React.FC<FileCarouselProps> = ({ filesJson, onChangeFilesJson }) => {
  const { uploadFile, getFile } = useContext(FileContext);
  const [attachedFiles, setAttachedFiles] = useState<AttachedFile[]>([]);
  const [previewIndex, setPreviewIndex] = useState<number | null>(null);
  const flatListRef = useRef<FlatList>(null);

  useEffect(() => {
    const fetchFiles = async () => {
      try {
        const fileIds: number[] = filesJson ? JSON.parse(filesJson) : [];
        const files: AttachedFile[] = [];

        for (const id of fileIds) {
          const dataUri = await getFile(id);
          if (dataUri) {
            files.push({ id, previewUri: dataUri });
          } else {
            console.warn(`Archivo ${id} no encontrado.`);
          }
        }

        setAttachedFiles(files);
      } catch (error) {
        console.error('Error parsing filesJson:', error);
        Alert.alert('Error', 'Formato invÃƒÂ¡lido en filesJson.');
      }
    };

    fetchFiles();
  }, [filesJson, getFile]);

  const pickFile = async (): Promise<{ uri: string; name: string; type: string; size: number } | null> => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        copyToCacheDirectory: true,
        multiple: false,
      });

      if (result?.assets && result.assets.length > 0) {
        const asset = result.assets[0];
        return {
          uri: asset.uri,
          name: asset.name,
          type: asset.mimeType || 'application/octet-stream',
          size: asset.size || 0,
        };
      }

      return null;
    } catch (error) {
      console.error('Error seleccionando documento:', error);
      return null;
    }
  };

  const handleAddFile = async () => {
    try {
      const pickedFile = await pickFile();
      if (!pickedFile) return;

      if (!pickedFile.uri.startsWith('file://')) {
        Alert.alert('Error', 'El URI del archivo no es vÃƒÂ¡lido.');
        return;
      }

      const fileData = await uploadFile(pickedFile.uri, pickedFile.name, pickedFile.type, pickedFile.size);
      if (!fileData) {
        Alert.alert('Error', 'No se pudo subir el archivo.');
        return;
      }

      const previewUri = await getFile(fileData.id);

      const newFile: AttachedFile = {
        id: fileData.id,
        originalName: fileData.original_name,
        fileType: fileData.file_type,
        previewUri: previewUri || '',
      };

      const updatedFiles = [...attachedFiles, newFile];
      setAttachedFiles(updatedFiles);
      onChangeFilesJson(JSON.stringify(updatedFiles.map((file) => file.id)));
    } catch (error: any) {
      console.error('Error agregando archivo:', error);
      Alert.alert('Error', error.message);
    }
  };

  const handleDeleteFile = (fileId: number) => {
    const updatedFiles = attachedFiles.filter(file => file.id !== fileId);
    setAttachedFiles(updatedFiles);
    onChangeFilesJson(JSON.stringify(updatedFiles.map(file => file.id)));
  };

  const renderPreviewModal = () => {
    if (previewIndex === null) return null;
  
    const isImage = attachedFiles[previewIndex]?.fileType?.toLowerCase().includes('image');
  
    if (isImage) {
      const imageSources = attachedFiles.map(f => ({ uri: f.previewUri }));
  
      return (
        <ImageViewing
          images={imageSources}
          imageIndex={previewIndex}
          visible={true}
          onRequestClose={() => setPreviewIndex(null)}
          FooterComponent={({ imageIndex }) => (
            <View style={styles.modalTopOverlay}>
              <Text style={styles.modalIndex}>{imageIndex + 1} / {attachedFiles.length}</Text>
              {/*<TouchableOpacity
                style={styles.modalDownloadButton}
                onPress={() => Linking.openURL(attachedFiles[imageIndex].previewUri)}
              >
                <Text style={styles.modalDownloadText}>Descargar</Text>
              </TouchableOpacity>*/}
              <TouchableOpacity
                style={styles.modalCloseButton}
                onPress={() => setPreviewIndex(null)}
              >
                <Text style={styles.modalCloseText}>Cerrar</Text>
              </TouchableOpacity>
            </View>
          )}
        />
      );
    }
  
    // Si no es imagen, usamos el modal tradicional
    const renderItem = ({ item }: { item: AttachedFile }) => {
      const lowerType = item.fileType?.toLowerCase() || '';
      const isVideo = lowerType.includes('video');
  
      return (
        <View style={styles.modalContent}>
          {isVideo ? (
            <Video source={{ uri: item.previewUri }} style={styles.fullImage} resizeMode="contain" controls />
          ) : (
            <Text style={styles.fileNameText}>{item.originalName}</Text>
          )}
        </View>
      );
    };
  
    return (
      <Modal visible transparent animationType="fade" onRequestClose={() => setPreviewIndex(null)}>
        <FlatList
          ref={flatListRef}
          data={attachedFiles}
          horizontal
          pagingEnabled
          initialScrollIndex={previewIndex}
          keyExtractor={(item) => item.id.toString()}
          renderItem={renderItem}
          style={styles.modalOverlay}
          onMomentumScrollEnd={(e) => {
            const index = Math.round(e.nativeEvent.contentOffset.x / screenWidth);
            setPreviewIndex(index);
          }}
        />
        <View style={styles.modalTopOverlay}>
          <Text style={styles.modalIndex}>{previewIndex + 1} / {attachedFiles.length}</Text>
          <TouchableOpacity
            style={styles.modalDownloadButton}
            onPress={() => Linking.openURL(attachedFiles[previewIndex].previewUri)}
          >
            <Text style={styles.modalDownloadText}>Descargar</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.modalCloseButton} onPress={() => setPreviewIndex(null)}>
            <Text style={styles.modalCloseText}>Cerrar</Text>
          </TouchableOpacity>
        </View>
      </Modal>
    );
  };
  

  return (
    <>
      <ScrollView
        horizontal
        pagingEnabled
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.carouselContainer}
      >
        {attachedFiles.map((file, index) => (
          <FileItem
            key={file.id.toString()}
            file={file}
            index={index}
            onDelete={handleDeleteFile}
            onPreview={setPreviewIndex}
          />
        ))}
        <TouchableOpacity style={[styles.fileItem, styles.addFileItem]} onPress={handleAddFile}>
          <Text style={styles.addButtonText}>Add File</Text>
        </TouchableOpacity>
      </ScrollView>
      {renderPreviewModal()}
    </>
  );
};

export default FileCarousel;

const styles = StyleSheet.create({
  carouselContainer: {
    alignItems: 'center',
    paddingHorizontal: 10,
  },
  fileItem: {
    width: 250,
    height: 200,
    marginHorizontal: 10,
    borderRadius: 8,
    overflow: 'hidden',
    backgroundColor: '#f0f0f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  media: {
    width: '100%',
    height: '100%',
  },
  defaultIcon: {
    backgroundColor: '#ccc',
    alignItems: 'center',
    justifyContent: 'center',
  },
  iconText: {
    color: '#555',
    fontSize: 18,
    fontWeight: 'bold',
  },
  deleteButton: {
    position: 'absolute',
    top: 5,
    right: 5,
    backgroundColor: 'rgba(255,0,0,0.7)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 12,
  },
  addFileItem: {
    backgroundColor: '#007bff',
    borderStyle: 'dashed',
    borderWidth: 2,
    borderColor: '#fff',
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.9)',
  },
  modalContent: {
    width: screenWidth,
    height: screenHeight,
    justifyContent: 'center',
    alignItems: 'center',
  },
  fullImage: {
    width: '100%',
    height: '100%',
  },
  fileNameText: {
    color: 'white',
    fontSize: 20,
    textAlign: 'center',
    padding: 20,
  },
  modalTopOverlay: {
    position: 'absolute',
    top: 40,
    left: 20,
    right: 20,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  modalCloseButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalCloseText: {
    color: '#fff',
    fontSize: 16,
  },
  modalIndex: {
    color: '#fff',
    fontSize: 16,
  },
  modalDownloadButton: {
    backgroundColor: 'rgba(255,255,255,0.2)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
  },
  modalDownloadText: {
    color: '#fff',
    fontSize: 16,
  },
});

---
