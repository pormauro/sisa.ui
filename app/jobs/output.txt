Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/app/jobs
File: create.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/app/jobs/create.tsx
import React, { useState, useContext, useEffect, useMemo } from 'react';
import {
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  ScrollView,
  Platform,
  View,
  ActivityIndicator
} from 'react-native';
import { useRouter } from 'expo-router';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Picker } from '@react-native-picker/picker';
import FileCarousel from '@/components/FileCarousel';
import { JobsContext } from '@/contexts/JobsContext';
import { PermissionsContext } from '@/contexts/PermissionsContext';
import { ClientsContext } from '@/contexts/ClientsContext';
import { FoldersContext } from '@/contexts/FoldersContext';
import { ProductsServicesContext } from '@/contexts/ProductsServicesContext';
import { StatusesContext, Status } from '@/contexts/StatusesContext';
import { ModalPicker, ModalPickerItem } from '@/components/ModalPicker';

export default function CreateJobScreen() {
  const router = useRouter();
  const { addJob } = useContext(JobsContext);
  const { permissions } = useContext(PermissionsContext);
  const { clients } = useContext(ClientsContext);
  const { folders } = useContext(FoldersContext);
  const { productsServices } = useContext(ProductsServicesContext);
  const { statuses, loadStatuses } = useContext(StatusesContext);

  // Estados para pickers que ahora son strings ('' = no seleccionado)
  const [selectedClient,  setSelectedClient]  = useState<string>('');
  const [selectedFolder,  setSelectedFolder]  = useState<string>('');
  const [selectedProduct, setSelectedProduct] = useState<string>('');
  const [selectedStatus,  setSelectedStatus]  = useState<ModalPickerItem | null>(null);

  const [typeOfWork, setTypeOfWork]               = useState<string>('');
  const [description, setDescription]             = useState<string>('');
  const [multiplicativeValue, setMultiplicativeValue] = useState<string>('1.00');
  const [attachedFiles, setAttachedFiles]         = useState<string>('');

  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate,   setEndDate]   = useState<Date | null>(null);

  const [startPickerShow, setStartPickerShow] = useState<boolean>(false);
  const [startPickerMode, setStartPickerMode] = useState<'date' | 'time'>('date');
  const [endPickerShow,   setEndPickerShow]   = useState<boolean>(false);
  const [endPickerMode,   setEndPickerMode]   = useState<'date' | 'time'>('date');

  const [loading, setLoading] = useState<boolean>(false);

  useEffect(() => {
    if (!permissions.includes('addJob')) {
      Alert.alert('Acceso denegado', 'No tienes permiso para agregar trabajos.');
      router.back();
    }
    loadStatuses();
  }, [permissions]);

  const filteredFolders = useMemo(() => {
    if (!selectedClient) return [];
    const clientIdNum = parseInt(selectedClient, 10);
    return folders.filter(f => f.client_id === clientIdNum);
  }, [folders, selectedClient]);

  const formatDateTime = (date: Date) => {
    const pad = (n: number) => n < 10 ? '0' + n : n;
    return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  };
  const formatTime = (date: Date) => {
    const pad = (n: number) => n < 10 ? '0' + n : n;
    return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  };

  const showStartDatepicker = () => { setStartPickerMode('date'); setStartPickerShow(true); };
  const showStartTimepicker = () => { setStartPickerMode('time'); setStartPickerShow(true); };
  const onChangeStartPicker = (_e: any, date?: Date) => {
    setStartPickerShow(false);
    if (!date) return;
    let h = 0, m = 0, s = 0;
    if (startPickerMode === 'date') {
      const now = new Date();
      h = startDate?.getHours() ?? now.getHours();
      m = startDate?.getMinutes() ?? now.getMinutes();
      s = startDate?.getSeconds() ?? now.getSeconds();
      date.setHours(h, m, s);
    } else {
      // time
      const base = startDate ?? new Date();
      date.setFullYear(base.getFullYear(), base.getMonth(), base.getDate());
    }
    setStartDate(date);
  };

  const showEndDatepicker = () => { setEndPickerMode('date'); setEndPickerShow(true); };
  const showEndTimepicker = () => { setEndPickerMode('time'); setEndPickerShow(true); };
  const onChangeEndPicker = (_e: any, date?: Date) => {
    setEndPickerShow(false);
    if (!date) return;
    let h = 0, m = 0, s = 0;
    if (endPickerMode === 'date') {
      const now = new Date();
      h = endDate?.getHours() ?? now.getHours();
      m = endDate?.getMinutes() ?? now.getMinutes();
      s = endDate?.getSeconds() ?? now.getSeconds();
      date.setHours(h, m, s);
    } else {
      const base = endDate ?? new Date();
      date.setFullYear(base.getFullYear(), base.getMonth(), base.getDate());
    }
    setEndDate(date);
  };

  const clearStart = () => setStartDate(null);
  const clearEnd   = () => setEndDate(null);

  const statusItems: ModalPickerItem[] = useMemo(() =>
    statuses.map((s: Status) => ({
      id: s.id,
      name: s.label,
      backgroundColor: s.background_color
    }))
  , [statuses]);

  const handleSubmit = async () => {
    if (!selectedClient || !selectedStatus) {
      Alert.alert('Error', 'Completa Cliente y Estado obligatorios.');
      return;
    }
    const jobData = {
      client_id: Number.parseInt(selectedClient, 10),
      folder_id: selectedFolder ?   Number.parseInt(selectedFolder, 10)   : null,
      product_service_id: selectedProduct ? Number.parseInt(selectedProduct, 10) : null,
      type_of_work:        typeOfWork,
      description,
      status:              selectedStatus.id.toString(),
      start_datetime:      startDate ? formatDateTime(startDate) : null,
      end_datetime:        endDate   ? formatDateTime(endDate)   : null,
      multiplicative_value: parseFloat(multiplicativeValue),
      attached_files:      attachedFiles || null,
    };

    setLoading(true);
    const created = await addJob(jobData);
    setLoading(false);

    if (created) {
      Alert.alert('Ã‰xito', 'Trabajo creado.');
      router.back();
    } else {
      Alert.alert('Error', 'No se pudo crear el trabajo.');
    }
  };

  return (
    <ScrollView contentContainerStyle={styles.container}>
      {/* Estado */}
      <Text style={styles.label}>Estado *</Text>
      <View style={styles.pickerWrap}>
        <ModalPicker
          items={statusItems}
          selectedItem={selectedStatus}
          onSelect={setSelectedStatus}
          placeholder="-- Selecciona un Estado --"
        />
      </View>

      {/* Tipo de trabajo */}
      <Text style={styles.label}>Tipo de trabajo</Text>
      <TextInput
        style={styles.input}
        placeholder="Ej: ReparaciÃ³n de equipo"
        value={typeOfWork}
        onChangeText={setTypeOfWork}
      />

      {/* DescripciÃ³n */}
      <Text style={styles.label}>DescripciÃ³n</Text>
      <TextInput
        style={[styles.input, { height: 80 }]}
        placeholder="Describe este trabajo"
        value={description}
        onChangeText={setDescription}
        multiline
      />

      {/* Cliente */}
      <Text style={styles.label}>Cliente *</Text>
      <View style={styles.pickerWrap}>
        <Picker
          selectedValue={selectedClient}
          onValueChange={setSelectedClient}
          style={styles.picker}
        >
          <Picker.Item label="-- Selecciona Cliente --" value="" />
          {clients.map(c => (
            <Picker.Item key={c.id} label={c.business_name} value={c.id.toString()} />
          ))}
        </Picker>
      </View>

      {/* Carpeta */}
      <Text style={styles.label}>Carpeta</Text>
      <View style={styles.pickerWrap}>
        <Picker
          selectedValue={selectedFolder}
          onValueChange={setSelectedFolder}
          enabled={!!selectedClient}
          style={styles.picker}
        >
          <Picker.Item label="-- Sin carpeta --" value="" />
          {filteredFolders.map(f => (
            <Picker.Item key={f.id} label={f.name} value={f.id.toString()} />
          ))}
        </Picker>
      </View>

      {/* Producto/Servicio */}
      <Text style={styles.label}>Producto/Servicio</Text>
      <View style={styles.pickerWrap}>
        <Picker
          selectedValue={selectedProduct}
          onValueChange={setSelectedProduct}
          style={styles.picker}
        >
          <Picker.Item label="-- Ninguno --" value="" />
          {productsServices.map(ps => (
            <Picker.Item key={ps.id} label={ps.description} value={ps.id.toString()} />
          ))}
        </Picker>
      </View>

      {/* Fecha y hora de inicio */}
      <Text style={styles.label}>Fecha de Inicio</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showStartDatepicker}>
        <Text style={styles.dateText}>{startDate ? startDate.toLocaleDateString() : 'Seleccionar Fecha'}</Text>
      </TouchableOpacity>
      <Text style={styles.label}>Hora de Inicio</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showStartTimepicker}>
        <Text style={styles.dateText}>{startDate ? formatTime(startDate) : 'Seleccionar Hora'}</Text>
      </TouchableOpacity>
      {startPickerShow && (
        <DateTimePicker
          value={startDate || new Date()}
          mode={startPickerMode}
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          is24Hour
          onChange={onChangeStartPicker}
        />
      )}
      {startDate && (
        <TouchableOpacity style={styles.clearBtn} onPress={clearStart}>
          <Text style={styles.clearText}>Eliminar inicio</Text>
        </TouchableOpacity>
      )}

      {/* Fecha y hora de fin */}
      <Text style={styles.label}>Fecha de Fin</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showEndDatepicker}>
        <Text style={styles.dateText}>{endDate ? endDate.toLocaleDateString() : 'Seleccionar Fecha'}</Text>
      </TouchableOpacity>
      <Text style={styles.label}>Hora de Fin</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showEndTimepicker}>
        <Text style={styles.dateText}>{endDate ? formatTime(endDate) : 'Seleccionar Hora'}</Text>
      </TouchableOpacity>
      {endPickerShow && (
        <DateTimePicker
          value={endDate || new Date()}
          mode={endPickerMode}
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          is24Hour
          onChange={onChangeEndPicker}
        />
      )}
      {endDate && (
        <TouchableOpacity style={styles.clearBtn} onPress={clearEnd}>
          <Text style={styles.clearText}>Eliminar fin</Text>
        </TouchableOpacity>
      )}

      {/* Valor multiplicador */}
      {/*<Text style={styles.label}>Valor multiplicador</Text>
      <TextInput
        style={styles.input}
        keyboardType="decimal-pad"
        value={multiplicativeValue}
        onChangeText={setMultiplicativeValue}
      />*/}

      {/* Archivos adjuntos */}
      <Text style={styles.label}>Archivos adjuntos</Text>
      <FileCarousel filesJson={attachedFiles} onChangeFilesJson={setAttachedFiles} />

      {/* BotÃ³n Crear */}
      <TouchableOpacity
        style={styles.submitBtn}
        onPress={handleSubmit}
        disabled={loading}
      >
        {loading
          ? <ActivityIndicator color="#fff" />
          : <Text style={styles.submitText}>Crear Trabajo</Text>
        }
      </TouchableOpacity>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: { padding: 16, backgroundColor: '#fff' },
  label: { marginTop: 12, fontSize: 16, fontWeight: '600' },
  pickerWrap: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    marginVertical: 8,
  },
  picker: { height: 50, width: '100%' },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    padding: 12,
    marginTop: 4,
    backgroundColor: '#fff'
  },
  dateBtn: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    padding: 12,
    marginVertical: 4
  },
  dateText: { color: '#555' },
  clearBtn: {
    backgroundColor: '#dc3545',
    borderRadius: 8,
    padding: 10,
    alignItems: 'center',
    marginVertical: 4
  },
  clearText: { color: '#fff', fontWeight: 'bold' },
  submitBtn: {
    marginTop: 20,
    backgroundColor: '#28a745',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center'
  },
  submitText: { color: '#fff', fontSize: 16, fontWeight: 'bold' }
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/app/jobs
File: index.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/app/jobs/index.tsx
import React, { useContext, useEffect, useState, useMemo } from 'react';
import { View, Text, FlatList, TouchableOpacity, TextInput, StyleSheet, ActivityIndicator, Alert } from 'react-native';
import { useRouter } from 'expo-router';
import Fuse from 'fuse.js';
import { JobsContext, Job } from '@/contexts/JobsContext';
import { PermissionsContext } from '@/contexts/PermissionsContext';
// Importamos el contexto de clientes
import { ClientsContext } from '@/contexts/ClientsContext';
import { StatusesContext, Status } from '@/contexts/StatusesContext';

export default function JobsScreen() {
  const { jobs, loadJobs, deleteJob } = useContext(JobsContext);
  const { permissions } = useContext(PermissionsContext);
  const { statuses } = useContext(StatusesContext);
  const { clients } = useContext(ClientsContext); // Accedemos al contexto de clientes
  const router = useRouter();
  const [search, setSearch] = useState('');
  const [loadingId, setLoadingId] = useState<number | null>(null);

  useEffect(() => {
    if (!permissions.includes('listJobs')) {
      Alert.alert('Acceso denegado', 'No tienes permiso para ver trabajos.');
      router.back();
    } else {
      loadJobs();
    }
  }, [permissions]);

  const fuse = new Fuse(jobs, { keys: ['description', 'type_of_work', 'status'] });
  const filteredJobs = useMemo(() => {
    if (!search) return jobs;
    const result = fuse.search(search);
    return result.map(r => r.item);
  }, [search, jobs]);

  // FunciÃ³n para buscar el objeto status que corresponda al trabajo
  const getJobStatus = (job: Job): Status | undefined => {
    return statuses.find(s => s.id === parseInt(job.status));
  };

  // FunciÃ³n para obtener el nombre del cliente segÃºn el client_id
  const getClientName = (clientId: number | null): string | undefined => {
    if (clientId == null) return undefined;
    const client = clients.find(client => client.id === clientId);
    return client ? client.business_name : undefined; // Usamos business_name para el nombre
  };

  const handleDelete = (id: number) => {
    Alert.alert('Eliminar trabajo', 'Â¿EstÃ¡s seguro?', [
      { text: 'Cancelar', style: 'cancel' },
      {
        text: 'Eliminar', style: 'destructive', onPress: async () => {
          setLoadingId(id);
          const success = await deleteJob(id);
          setLoadingId(null);
          if (!success)
            Alert.alert('Error', 'No se pudo eliminar el trabajo.');
        }
      }
    ]);
  };

  const renderItem = ({ item }: { item: Job }) => {
    const jobStatus = getJobStatus(item);
    const clientName = getClientName(item.client_id); // Usamos client_id para obtener el nombre del cliente

    return (
      <TouchableOpacity
        style={styles.itemContainer}
        onLongPress={() => router.push(`./jobs/${item.id}`)}
      >
        <View style={styles.itemContent}>
          {/* TÃ­tulo: Tipo de trabajo */}
          <Text style={styles.title}>{item.type_of_work}</Text>
          
          {/* SubtÃ­tulo: Nombre del cliente */}
          <Text style={styles.subTitle}>{clientName ? clientName : 'Cliente desconocido'}</Text>

          {jobStatus ? (
            <View style={[styles.statusContainer, { backgroundColor: jobStatus.background_color }]}>
              <Text style={styles.statusLabel}>{jobStatus.label}</Text>
            </View>
          ) : (
            <Text style={styles.statusFallback}>Estado: {item.status}</Text>
          )}
        </View>
        <TouchableOpacity onPress={() => handleDelete(item.id)}>
          {loadingId === item.id ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.trash}>ðŸ—‘ï¸�</Text>
          )}
        </TouchableOpacity>
      </TouchableOpacity>
    );
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.search}
        value={search}
        onChangeText={setSearch}
        placeholder="Buscar trabajo..."
      />
      <FlatList
        data={filteredJobs}
        keyExtractor={(item) => item.id.toString()}
        renderItem={renderItem}
        ListEmptyComponent={<Text style={styles.empty}>No hay trabajos cargados</Text>}
      />
      <TouchableOpacity style={styles.addButton} onPress={() => router.push('/jobs/create')}>
        <Text style={styles.addText}>âž• Nuevo Trabajo</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff' },
  search: { borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 12, marginBottom: 10 },
  itemContainer: { 
    flexDirection: 'row', 
    alignItems: 'center', 
    justifyContent: 'space-between', 
    borderBottomWidth: 1, 
    borderColor: '#eee', 
    paddingVertical: 12 
  },
  itemContent: { flex: 1, marginRight: 10 },
  title: { fontWeight: 'bold', fontSize: 16 },
  subTitle: { fontSize: 14, color: '#555', marginVertical: 4 }, // Estilo para el subtÃ­tulo (nombre del cliente)
  statusContainer: {
    marginTop: 4,
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 4,
    alignSelf: 'flex-start'
  },
  statusLabel: { color: '#fff', fontSize: 12, fontWeight: 'bold' },
  statusFallback: { fontSize: 12, color: '#888', marginTop: 4 },
  trash: { fontSize: 18, color: 'red', paddingHorizontal: 12 },
  addButton: { 
    backgroundColor: '#007BFF', 
    padding: 16, 
    borderRadius: 30, 
    position: 'absolute', 
    right: 16, 
    bottom: 32, 
    alignItems: 'center'
  },
  addText: { color: '#fff', fontWeight: 'bold', fontSize: 16 },
  empty: { marginTop: 20, textAlign: 'center', fontSize: 16 },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/app/jobs
File: output.txt
Content:
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/app/jobs
File: create.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/app/jobs/create.tsx
import React, { useState, useContext, useEffect, useMemo } from 'react';
import {
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  ScrollView,
  Platform,
  View,
  ActivityIndicator
} from 'react-native';
import { useRouter } from 'expo-router';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Picker } from '@react-native-picker/picker';
import FileCarousel from '@/components/FileCarousel';
import { JobsContext } from '@/contexts/JobsContext';
import { PermissionsContext } from '@/contexts/PermissionsContext';
import { ClientsContext } from '@/contexts/ClientsContext';
import { FoldersContext } from '@/contexts/FoldersContext';
import { ProductsServicesContext } from '@/contexts/ProductsServicesContext';
import { StatusesContext, Status } from '@/contexts/StatusesContext';
import { ModalPicker, ModalPickerItem } from '@/components/ModalPicker';

export default function CreateJobScreen() {
  const router = useRouter();
  const { addJob } = useContext(JobsContext);
  const { permissions } = useContext(PermissionsContext);
  const { clients } = useContext(ClientsContext);
  const { folders } = useContext(FoldersContext);
  const { productsServices } = useContext(ProductsServicesContext);
  const { statuses, loadStatuses } = useContext(StatusesContext);

  // Estados para pickers que ahora son strings ('' = no seleccionado)
  const [selectedClient,  setSelectedClient]  = useState<string>('');
  const [selectedFolder,  setSelectedFolder]  = useState<string>('');
  const [selectedProduct, setSelectedProduct] = useState<string>('');
  const [selectedStatus,  setSelectedStatus]  = useState<ModalPickerItem | null>(null);

  const [typeOfWork, setTypeOfWork]               = useState<string>('');
  const [description, setDescription]             = useState<string>('');
  const [multiplicativeValue, setMultiplicativeValue] = useState<string>('1.00');
  const [attachedFiles, setAttachedFiles]         = useState<string>('');

  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate,   setEndDate]   = useState<Date | null>(null);

  const [startPickerShow, setStartPickerShow] = useState<boolean>(false);
  const [startPickerMode, setStartPickerMode] = useState<'date' | 'time'>('date');
  const [endPickerShow,   setEndPickerShow]   = useState<boolean>(false);
  const [endPickerMode,   setEndPickerMode]   = useState<'date' | 'time'>('date');

  const [loading, setLoading] = useState<boolean>(false);

  useEffect(() => {
    if (!permissions.includes('addJob')) {
      Alert.alert('Acceso denegado', 'No tienes permiso para agregar trabajos.');
      router.back();
    }
    loadStatuses();
  }, [permissions]);

  const filteredFolders = useMemo(() => {
    if (!selectedClient) return [];
    const clientIdNum = parseInt(selectedClient, 10);
    return folders.filter(f => f.client_id === clientIdNum);
  }, [folders, selectedClient]);

  const formatDateTime = (date: Date) => {
    const pad = (n: number) => n < 10 ? '0' + n : n;
    return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  };
  const formatTime = (date: Date) => {
    const pad = (n: number) => n < 10 ? '0' + n : n;
    return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  };

  const showStartDatepicker = () => { setStartPickerMode('date'); setStartPickerShow(true); };
  const showStartTimepicker = () => { setStartPickerMode('time'); setStartPickerShow(true); };
  const onChangeStartPicker = (_e: any, date?: Date) => {
    setStartPickerShow(false);
    if (!date) return;
    let h = 0, m = 0, s = 0;
    if (startPickerMode === 'date') {
      const now = new Date();
      h = startDate?.getHours() ?? now.getHours();
      m = startDate?.getMinutes() ?? now.getMinutes();
      s = startDate?.getSeconds() ?? now.getSeconds();
      date.setHours(h, m, s);
    } else {
      // time
      const base = startDate ?? new Date();
      date.setFullYear(base.getFullYear(), base.getMonth(), base.getDate());
    }
    setStartDate(date);
  };

  const showEndDatepicker = () => { setEndPickerMode('date'); setEndPickerShow(true); };
  const showEndTimepicker = () => { setEndPickerMode('time'); setEndPickerShow(true); };
  const onChangeEndPicker = (_e: any, date?: Date) => {
    setEndPickerShow(false);
    if (!date) return;
    let h = 0, m = 0, s = 0;
    if (endPickerMode === 'date') {
      const now = new Date();
      h = endDate?.getHours() ?? now.getHours();
      m = endDate?.getMinutes() ?? now.getMinutes();
      s = endDate?.getSeconds() ?? now.getSeconds();
      date.setHours(h, m, s);
    } else {
      const base = endDate ?? new Date();
      date.setFullYear(base.getFullYear(), base.getMonth(), base.getDate());
    }
    setEndDate(date);
  };

  const clearStart = () => setStartDate(null);
  const clearEnd   = () => setEndDate(null);

  const statusItems: ModalPickerItem[] = useMemo(() =>
    statuses.map((s: Status) => ({
      id: s.id,
      name: s.label,
      backgroundColor: s.background_color
    }))
  , [statuses]);

  const handleSubmit = async () => {
    if (!selectedClient || !selectedStatus) {
      Alert.alert('Error', 'Completa Cliente y Estado obligatorios.');
      return;
    }
    const jobData = {
      client_id: Number.parseInt(selectedClient, 10),
      folder_id: selectedFolder ?   Number.parseInt(selectedFolder, 10)   : null,
      product_service_id: selectedProduct ? Number.parseInt(selectedProduct, 10) : null,
      type_of_work:        typeOfWork,
      description,
      status:              selectedStatus.id.toString(),
      start_datetime:      startDate ? formatDateTime(startDate) : null,
      end_datetime:        endDate   ? formatDateTime(endDate)   : null,
      multiplicative_value: parseFloat(multiplicativeValue),
      attached_files:      attachedFiles || null,
    };

    setLoading(true);
    const created = await addJob(jobData);
    setLoading(false);

    if (created) {
      Alert.alert('Ãƒâ€°xito', 'Trabajo creado.');
      router.back();
    } else {
      Alert.alert('Error', 'No se pudo crear el trabajo.');
    }
  };

  return (
    <ScrollView contentContainerStyle={styles.container}>
      {/* Estado */}
      <Text style={styles.label}>Estado *</Text>
      <View style={styles.pickerWrap}>
        <ModalPicker
          items={statusItems}
          selectedItem={selectedStatus}
          onSelect={setSelectedStatus}
          placeholder="-- Selecciona un Estado --"
        />
      </View>

      {/* Tipo de trabajo */}
      <Text style={styles.label}>Tipo de trabajo</Text>
      <TextInput
        style={styles.input}
        placeholder="Ej: ReparaciÃƒÂ³n de equipo"
        value={typeOfWork}
        onChangeText={setTypeOfWork}
      />

      {/* DescripciÃƒÂ³n */}
      <Text style={styles.label}>DescripciÃƒÂ³n</Text>
      <TextInput
        style={[styles.input, { height: 80 }]}
        placeholder="Describe este trabajo"
        value={description}
        onChangeText={setDescription}
        multiline
      />

      {/* Cliente */}
      <Text style={styles.label}>Cliente *</Text>
      <View style={styles.pickerWrap}>
        <Picker
          selectedValue={selectedClient}
          onValueChange={setSelectedClient}
          style={styles.picker}
        >
          <Picker.Item label="-- Selecciona Cliente --" value="" />
          {clients.map(c => (
            <Picker.Item key={c.id} label={c.business_name} value={c.id.toString()} />
          ))}
        </Picker>
      </View>

      {/* Carpeta */}
      <Text style={styles.label}>Carpeta</Text>
      <View style={styles.pickerWrap}>
        <Picker
          selectedValue={selectedFolder}
          onValueChange={setSelectedFolder}
          enabled={!!selectedClient}
          style={styles.picker}
        >
          <Picker.Item label="-- Sin carpeta --" value="" />
          {filteredFolders.map(f => (
            <Picker.Item key={f.id} label={f.name} value={f.id.toString()} />
          ))}
        </Picker>
      </View>

      {/* Producto/Servicio */}
      <Text style={styles.label}>Producto/Servicio</Text>
      <View style={styles.pickerWrap}>
        <Picker
          selectedValue={selectedProduct}
          onValueChange={setSelectedProduct}
          style={styles.picker}
        >
          <Picker.Item label="-- Ninguno --" value="" />
          {productsServices.map(ps => (
            <Picker.Item key={ps.id} label={ps.description} value={ps.id.toString()} />
          ))}
        </Picker>
      </View>

      {/* Fecha y hora de inicio */}
      <Text style={styles.label}>Fecha de Inicio</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showStartDatepicker}>
        <Text style={styles.dateText}>{startDate ? startDate.toLocaleDateString() : 'Seleccionar Fecha'}</Text>
      </TouchableOpacity>
      <Text style={styles.label}>Hora de Inicio</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showStartTimepicker}>
        <Text style={styles.dateText}>{startDate ? formatTime(startDate) : 'Seleccionar Hora'}</Text>
      </TouchableOpacity>
      {startPickerShow && (
        <DateTimePicker
          value={startDate || new Date()}
          mode={startPickerMode}
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          is24Hour
          onChange={onChangeStartPicker}
        />
      )}
      {startDate && (
        <TouchableOpacity style={styles.clearBtn} onPress={clearStart}>
          <Text style={styles.clearText}>Eliminar inicio</Text>
        </TouchableOpacity>
      )}

      {/* Fecha y hora de fin */}
      <Text style={styles.label}>Fecha de Fin</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showEndDatepicker}>
        <Text style={styles.dateText}>{endDate ? endDate.toLocaleDateString() : 'Seleccionar Fecha'}</Text>
      </TouchableOpacity>
      <Text style={styles.label}>Hora de Fin</Text>
      <TouchableOpacity style={styles.dateBtn} onPress={showEndTimepicker}>
        <Text style={styles.dateText}>{endDate ? formatTime(endDate) : 'Seleccionar Hora'}</Text>
      </TouchableOpacity>
      {endPickerShow && (
        <DateTimePicker
          value={endDate || new Date()}
          mode={endPickerMode}
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          is24Hour
          onChange={onChangeEndPicker}
        />
      )}
      {endDate && (
        <TouchableOpacity style={styles.clearBtn} onPress={clearEnd}>
          <Text style={styles.clearText}>Eliminar fin</Text>
        </TouchableOpacity>
      )}

      {/* Valor multiplicador */}
      {/*<Text style={styles.label}>Valor multiplicador</Text>
      <TextInput
        style={styles.input}
        keyboardType="decimal-pad"
        value={multiplicativeValue}
        onChangeText={setMultiplicativeValue}
      />*/}

      {/* Archivos adjuntos */}
      <Text style={styles.label}>Archivos adjuntos</Text>
      <FileCarousel filesJson={attachedFiles} onChangeFilesJson={setAttachedFiles} />

      {/* BotÃƒÂ³n Crear */}
      <TouchableOpacity
        style={styles.submitBtn}
        onPress={handleSubmit}
        disabled={loading}
      >
        {loading
          ? <ActivityIndicator color="#fff" />
          : <Text style={styles.submitText}>Crear Trabajo</Text>
        }
      </TouchableOpacity>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: { padding: 16, backgroundColor: '#fff' },
  label: { marginTop: 12, fontSize: 16, fontWeight: '600' },
  pickerWrap: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    marginVertical: 8,
  },
  picker: { height: 50, width: '100%' },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    padding: 12,
    marginTop: 4,
    backgroundColor: '#fff'
  },
  dateBtn: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    padding: 12,
    marginVertical: 4
  },
  dateText: { color: '#555' },
  clearBtn: {
    backgroundColor: '#dc3545',
    borderRadius: 8,
    padding: 10,
    alignItems: 'center',
    marginVertical: 4
  },
  clearText: { color: '#fff', fontWeight: 'bold' },
  submitBtn: {
    marginTop: 20,
    backgroundColor: '#28a745',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center'
  },
  submitText: { color: '#fff', fontSize: 16, fontWeight: 'bold' }
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/app/jobs
File: [id].tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/app/jobs/[id].tsx
import React, { useState, useContext, useEffect, useMemo } from 'react';
import {
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  ScrollView,
  Platform,
  ActivityIndicator,
  View
} from 'react-native';
import { useRouter, useLocalSearchParams } from 'expo-router';
import DateTimePicker from '@react-native-community/datetimepicker';
import { ModalPicker, ModalPickerItem } from '@/components/ModalPicker';
import FileCarousel from '@/components/FileCarousel';
import { JobsContext } from '@/contexts/JobsContext';
import { PermissionsContext } from '@/contexts/PermissionsContext';
import { ClientsContext } from '@/contexts/ClientsContext';
import { FoldersContext } from '@/contexts/FoldersContext';
import { ProductsServicesContext } from '@/contexts/ProductsServicesContext';
import { StatusesContext, Status } from '@/contexts/StatusesContext';
import { calculateTimeDifference } from '@/config/Utils';

export default function EditJobScreen() {
  const router = useRouter();
  const { id } = useLocalSearchParams<{ id: string }>();
  const jobId = Number(id);

  // Contextos
  const { jobs, updateJob, deleteJob } = useContext(JobsContext);
  const { permissions } = useContext(PermissionsContext);
  const { clients } = useContext(ClientsContext);
  const { folders } = useContext(FoldersContext);
  const { productsServices } = useContext(ProductsServicesContext);
  const { statuses, loadStatuses } = useContext(StatusesContext);

  // Buscamos el trabajo a editar
  const job = jobs.find((j) => j.id === jobId);

  // Permisos
  const canEdit = permissions.includes('updateJob');
  const canDelete = permissions.includes('deleteJob');

  // Estados para los selectores (usamos ModalPickerItem para tener toda la info)
  const [selectedClient, setSelectedClient] = useState<ModalPickerItem | null>(null);
  const [selectedFolder, setSelectedFolder] = useState<ModalPickerItem | null>(null);
  const [selectedProduct, setSelectedProduct] = useState<ModalPickerItem | null>(null);
  // Para el estado, se guarda el objeto completo y se usarÃ¡ su propiedad para mostrar color y label
  const [selectedStatus, setSelectedStatus] = useState<ModalPickerItem | null>(null);

  // Otros campos
  const [typeOfWork, setTypeOfWork] = useState<string>('');
  const [description, setDescription] = useState<string>('');
  const [multiplicativeValue, setMultiplicativeValue] = useState<string>('1.00');
  const [attachedFiles, setAttachedFiles] = useState<string>('');

  // Fechas
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);

  // Control de pickers de fecha/hora
  const [startPickerShow, setStartPickerShow] = useState<boolean>(false);
  const [startPickerMode, setStartPickerMode] = useState<'date' | 'time'>('date');
  const [endPickerShow, setEndPickerShow] = useState<boolean>(false);
  const [endPickerMode, setEndPickerMode] = useState<'date' | 'time'>('date');
  const [difHours, setDifHours] = useState<string>('');
  const [difMinutes, setDifMinutes] = useState<string>('');

  const [loading, setLoading] = useState<boolean>(false);

  const difTime = () => {
    if (startDate && endDate) {
      const { hours, minutes } = calculateTimeDifference(startDate, endDate);
      setDifHours(hours.toString());
      setDifMinutes(minutes.toString());
    }
  };

  // FunciÃ³n para mostrar la diferencia horaria
  useEffect(() => {
    difTime();
  }, [startDate, endDate]);
  // Al cargar el componente, si no se encuentra el trabajo se vuelve atrÃ¡s;
  // ademÃ¡s, asignamos al estado cada campo usando la informaciÃ³n del trabajo.
  useEffect(() => {
    if (!job) {
      Alert.alert('Error', 'Trabajo no encontrado.');
      router.back();
      return;
    }

    // Cliente
    const clientObj = clients.find(c => c.id === job.client_id);
    setSelectedClient(clientObj ? { id: clientObj.id, name: clientObj.business_name } : null);

    // Carpeta
    const folderObj = folders.find(f => f.id === job.folder_id);
    setSelectedFolder(folderObj ? { id: folderObj.id, name: folderObj.name } : null);

    // Producto/Servicio
    const productObj = productsServices.find(ps => ps.id === job.product_service_id);
    setSelectedProduct(productObj ? { id: productObj.id, name: productObj.description } : null);

    // Estado: se asume que job.status es un string que contiene el id del estado.
    const statusIdNum = job.status ? parseInt(job.status) : null;
    const statusObj = statuses.find(s => s.id === statusIdNum);
    setSelectedStatus(statusObj ? { id: statusObj.id, name: statusObj.label, backgroundColor: statusObj.background_color } : null);

    // Otros campos
    setTypeOfWork(job.type_of_work || '');
    setDescription(job.description || '');
    setMultiplicativeValue(job.multiplicative_value.toString());
    setAttachedFiles(job.attached_files || '');

    // Fechas
    setStartDate(job.start_datetime ? parseDateTime(job.start_datetime) : null);
    setEndDate(job.end_datetime ? parseDateTime(job.end_datetime) : null);
  }, [job, clients, folders, productsServices, statuses]);

  // Cargar estados dinÃ¡micos al montar, en caso que no se hayan cargado
  useEffect(() => {
    loadStatuses();
    difTime();
  }, []);

  // Helpers: parse y formatea fechas
  function parseDateTime(datetimeString: string): Date {
    return new Date(datetimeString.replace(' ', 'T'));
  }
  function formatDateTime(date: Date): string {
    const pad = (n: number) => (n < 10 ? '0' + n : n);
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  }
  function formatTime(date: Date): string {
    const pad = (n: number) => (n < 10 ? '0' + n : n);
    return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
  }

  // Funciones para pickers de inicio
  const showStartDatepicker = () => { setStartPickerMode('date'); setStartPickerShow(true); };
  const showStartTimepicker = () => { setStartPickerMode('time'); setStartPickerShow(true); };
  const onChangeStartPicker = (event: any, selectedDate?: Date) => {
    setStartPickerShow(false);
    if (selectedDate) {
      if (startPickerMode === 'date') {
        let hour: number, minute: number, second: number;
        if (startDate) {
          if (startDate.getHours() === 0 && startDate.getMinutes() === 0 && startDate.getSeconds() === 0) {
            const now = new Date();
            hour = now.getHours();
            minute = now.getMinutes();
            second = now.getSeconds();
          } else {
            hour = startDate.getHours();
            minute = startDate.getMinutes();
            second = startDate.getSeconds();
          }
        } else {
          const now = new Date();
          hour = now.getHours();
          minute = now.getMinutes();
          second = now.getSeconds();
        }
        const newDate = new Date(
          selectedDate.getFullYear(),
          selectedDate.getMonth(),
          selectedDate.getDate(),
          hour,
          minute,
          second
        );
        setStartDate(newDate);
      } else {
        if (startDate) {
          const newDate = new Date(
            startDate.getFullYear(),
            startDate.getMonth(),
            startDate.getDate(),
            selectedDate.getHours(),
            selectedDate.getMinutes(),
            selectedDate.getSeconds()
          );
          setStartDate(newDate);
        } else {
          const today = new Date();
          setStartDate(new Date(
            today.getFullYear(),
            today.getMonth(),
            today.getDate(),
            selectedDate.getHours(),
            selectedDate.getMinutes(),
            selectedDate.getSeconds()
          ));
        }
      }
    }
  };

  // Funciones para pickers de fin
  const showEndDatepicker = () => { setEndPickerMode('date'); setEndPickerShow(true); };
  const showEndTimepicker = () => { setEndPickerMode('time'); setEndPickerShow(true); };
  const onChangeEndPicker = (event: any, selectedDate?: Date) => {
    setEndPickerShow(false);
    if (selectedDate) {
      if (endPickerMode === 'date') {
        let hour: number, minute: number, second: number;
        if (endDate) {
          if (endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.getSeconds() === 0) {
            const now = new Date();
            hour = now.getHours();
            minute = now.getMinutes();
            second = now.getSeconds();
          } else {
            hour = endDate.getHours();
            minute = endDate.getMinutes();
            second = endDate.getSeconds();
          }
        } else {
          const now = new Date();
          hour = now.getHours();
          minute = now.getMinutes();
          second = now.getSeconds();
        }
        const newDate = new Date(
          selectedDate.getFullYear(),
          selectedDate.getMonth(),
          selectedDate.getDate(),
          hour,
          minute,
          second
        );
        setEndDate(newDate);
      } else {
        if (endDate) {
          const newDate = new Date(
            endDate.getFullYear(),
            endDate.getMonth(),
            endDate.getDate(),
            selectedDate.getHours(),
            selectedDate.getMinutes(),
            selectedDate.getSeconds()
          );
          setEndDate(newDate);
        } else {
          const today = new Date();
          setEndDate(new Date(
            today.getFullYear(),
            today.getMonth(),
            today.getDate(),
            selectedDate.getHours(),
            selectedDate.getMinutes(),
            selectedDate.getSeconds()
          ));
        }
      }
    }
  };

  // Limpia fechas
  const clearStartDateTime = () => setStartDate(null);
  const clearEndDateTime = () => setEndDate(null);

  // PreparaciÃ³n de Ã­tems para los ModalPicker de cada selector
  const clientItems: ModalPickerItem[] = useMemo(() => 
    clients.map(c => ({ id: c.id, name: c.business_name })), [clients]);
  const folderItems: ModalPickerItem[] = useMemo(() =>
    folders.filter(f => selectedClient ? f.client_id === selectedClient.id : false)
      .map(f => ({ id: f.id, name: f.name })), [folders, selectedClient]);
  const productItems: ModalPickerItem[] = useMemo(() =>
    productsServices.map(ps => ({ id: ps.id, name: ps.description })), [productsServices]);
  const statusItems: ModalPickerItem[] = useMemo(() =>
    statuses.map(s => ({ id: s.id, name: s.label, backgroundColor: s.background_color })), [statuses]);

  // FunciÃ³n para enviar la actualizaciÃ³n
  const handleSubmit = async () => {
    if (!selectedClient || selectedStatus === null) {
      Alert.alert('Error', 'Por favor completa los campos obligatorios (Cliente y Estado).');
      return;
    }
    const startDatetime = startDate ? formatDateTime(startDate) : null;
    const endDatetime = endDate ? formatDateTime(endDate) : null;
  
    setLoading(true);
    const updated = await updateJob(jobId, {
      client_id: selectedClient ? Number(selectedClient.id) : null,
      product_service_id: selectedProduct ? Number(selectedProduct.id) : null,
      folder_id: selectedFolder ? Number(selectedFolder.id) : null,
      type_of_work: typeOfWork,
      description,
      // Se envÃ­a el id del estado convertido a string
      status: selectedStatus.id.toString(),
      start_datetime: startDatetime,
      end_datetime: endDatetime,
      multiplicative_value: parseFloat(multiplicativeValue),
      attached_files: attachedFiles || null,
    });
    setLoading(false);
    if (updated) {
      Alert.alert('Ã‰xito', 'Trabajo actualizado.');
      router.back();
    } else {
      Alert.alert('Error', 'No se pudo actualizar el trabajo.');
    }
  };

  // FunciÃ³n para eliminar el trabajo
  const handleDelete = () => {
    Alert.alert('Eliminar trabajo', 'Â¿Deseas eliminar este trabajo?', [
      { text: 'Cancelar', style: 'cancel' },
      {
        text: 'Eliminar',
        style: 'destructive',
        onPress: async () => {
          setLoading(true);
          const success = await deleteJob(jobId);
          setLoading(false);
          if (success) {
            Alert.alert('Ã‰xito', 'Trabajo eliminado.');
            router.back();
          } else {
            Alert.alert('Error', 'No se pudo eliminar el trabajo.');
          }
        },
      },
    ]);
  };

  return (
    <ScrollView contentContainerStyle={styles.container}>

      {/* ESTADO */}
      <Text style={styles.label}>Estado</Text>
      <View style={styles.pickerContainer}>
        <ModalPicker
          items={statusItems}
          selectedItem={selectedStatus}
          onSelect={(item: ModalPickerItem) => setSelectedStatus(item)}
          placeholder="-- Selecciona un Estado --"
        />
      </View>


      {/* TIPO DE TRABAJO */}
      <Text style={styles.label}>Trabajo</Text>
      <TextInput
        style={styles.input}
        value={typeOfWork}
        onChangeText={setTypeOfWork}
        editable={canEdit}
        placeholder="Ej: ReparaciÃ³n de equipo, etc."
      />

      {/* DESCRIPCIÃ“N */}
      <Text style={styles.label}>DescripciÃ³n</Text>
      <TextInput
        style={[styles.input, { height: 80 }]}
        multiline
        value={description}
        onChangeText={setDescription}
        editable={canEdit}
        placeholder="Describe este trabajo"
      />

      {/* CLIENTE */}
      <Text style={styles.label}>Cliente *</Text>
      <View style={styles.pickerContainer}>
        <ModalPicker
          items={clientItems}
          selectedItem={selectedClient}
          onSelect={setSelectedClient}
          placeholder="-- Selecciona un Cliente --"
        />
      </View>

      {/* CARPETA */}
      <Text style={styles.label}>Carpeta</Text>
      <View style={styles.pickerContainer}>
        <ModalPicker
          items={folderItems}
          selectedItem={selectedFolder}
          onSelect={setSelectedFolder}
          placeholder="-- Sin carpeta --"
        />
      </View>

      {/* PRODUCTO/SERVICIO */}
      <Text style={styles.label}>Producto/Servicio</Text>
      <View style={styles.pickerContainer}>
        <ModalPicker
          items={productItems}
          selectedItem={selectedProduct}
          onSelect={setSelectedProduct}
          placeholder="-- Ninguno --"
        />
      </View>

      {/* FECHAS Y HORAS - INICIO */}
      <Text style={styles.label}>Fecha de Inicio</Text>
      <TouchableOpacity style={[styles.dateButton, { marginBottom: 6 }]} onPress={() => canEdit && showStartDatepicker()}>
        <Text style={styles.dateButtonText}>
          {startDate ? startDate.toLocaleDateString() : 'Seleccionar Fecha'}
        </Text>
      </TouchableOpacity>
      <Text style={styles.label}>Hora de Inicio</Text>
      <TouchableOpacity style={[styles.dateButton, { marginBottom: 6 }]} onPress={() => canEdit && showStartTimepicker()}>
        <Text style={styles.dateButtonText}>
          {startDate ? formatTime(startDate) : 'Seleccionar Hora'}
        </Text>
      </TouchableOpacity>
      {startPickerShow && (
        <DateTimePicker
          value={startDate || new Date()}
          mode={startPickerMode}
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          is24Hour
          onChange={onChangeStartPicker}
        />
      )}
      {startDate && (
        <TouchableOpacity style={styles.clearButton} onPress={clearStartDateTime}>
          <Text style={styles.clearButtonText}>Eliminar fecha/hora de Inicio</Text>
        </TouchableOpacity>
      )}

      {/* FECHAS Y HORAS - FIN */}
      <Text style={styles.label}>Fecha de Fin</Text>
      <TouchableOpacity style={[styles.dateButton, { marginBottom: 6 }]} onPress={() => canEdit && showEndDatepicker()}>
        <Text style={styles.dateButtonText}>
          {endDate ? endDate.toLocaleDateString() : 'Seleccionar Fecha'}
        </Text>
      </TouchableOpacity>
      <Text style={styles.label}>Hora de Fin</Text>
      <TouchableOpacity style={[styles.dateButton, { marginBottom: 6 }]} onPress={() => canEdit && showEndTimepicker()}>
        <Text style={styles.dateButtonText}>
          {endDate ? formatTime(endDate) : 'Seleccionar Hora'}
        </Text>
      </TouchableOpacity>
      {endPickerShow && (
        <DateTimePicker
          value={endDate || new Date()}
          mode={endPickerMode}
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          is24Hour
          onChange={onChangeEndPicker}
        />
      )}
      {endDate && (
        <TouchableOpacity style={styles.clearButton} onPress={clearEndDateTime}>
          <Text style={styles.clearButtonText}>Eliminar fecha/hora de Fin</Text>
        </TouchableOpacity>
      )}

      {/* DIFERENCIA HORARIA */}
      <Text style={styles.label}>Tiempo trabajado {difHours} horas, {difMinutes} minutos</Text>

      {/* VALOR MULTIPLICADOR */}
    {/*}  <Text style={styles.label}>Valor multiplicador</Text>
      <TextInput
        style={styles.input}
        keyboardType="decimal-pad"
        value={multiplicativeValue}
        onChangeText={setMultiplicativeValue}
        editable={canEdit}
      />*/}

      {/* ARCHIVOS ADJUNTOS */}
      <Text style={styles.label}>Archivos adjuntos</Text>
      <FileCarousel 
        filesJson={attachedFiles} 
        onChangeFilesJson={setAttachedFiles} 
      />

      {/* BOTÃ“N ACTUALIZAR */}
      {canEdit && (
        <TouchableOpacity style={styles.buttonPrimary} onPress={handleSubmit} disabled={loading}>
          {loading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.buttonText}>Actualizar</Text>
          )}
        </TouchableOpacity>
      )}

      {/* BOTÃ“N ELIMINAR */}
      {canDelete && (
        <TouchableOpacity style={styles.buttonDanger} onPress={handleDelete} disabled={loading}>
          {loading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.buttonText}>Eliminar</Text>
          )}
        </TouchableOpacity>
      )}
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: { padding: 16, backgroundColor: '#fff', flexGrow: 1 },
  label: { marginVertical: 8, fontSize: 16, fontWeight: '600' },
  pickerContainer: { marginTop: 4, marginBottom: 8 },
  input: { borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 12, marginVertical: 4, backgroundColor: '#fff' },
  dateButton: { borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 12, marginBottom: 8 },
  dateButtonText: { color: '#555' },
  buttonPrimary: { marginTop: 20, backgroundColor: '#007BFF', padding: 16, borderRadius: 8, alignItems: 'center' },
  buttonDanger: { marginTop: 10, backgroundColor: '#dc3545', padding: 16, borderRadius: 8, alignItems: 'center' },
  buttonText: { color: '#fff', fontSize: 16, fontWeight: 'bold' },
  clearButton: { backgroundColor: '#dc3545', padding: 12, borderRadius: 8, alignItems: 'center', marginVertical: 8 },
  clearButtonText: { color: '#fff', fontSize: 14, fontWeight: 'bold' },
  // Preview de estado
  statusPreview: {
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 4,
    alignSelf: 'flex-start',
    marginTop: 4,
  },
  statusPreviewText: { color: '#fff', fontSize: 12, fontWeight: 'bold' },
});

---
Folder: C:/Users/Mauri/Documents/GitHub/sisa.ui/app/jobs
File: _layout.tsx
Content:
// C:/Users/Mauri/Documents/GitHub/router/app/jobs/_layout.tsx
import React from 'react';
import { Stack } from 'expo-router';

export default function JobsLayout() {
  return (
    <Stack>
      <Stack.Screen name="index" options={{ title: 'Trabajos' }} />
      <Stack.Screen name="create" options={{ title: 'Nueva Trabajo' }} />
      <Stack.Screen name="[id]" options={{ title: 'Editar Trabajo' }} />
    </Stack>
  );
}

---
