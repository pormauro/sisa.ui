Folder: C:\Users\porma\Desktop\sisa.ui\app
File: .index.js
Content:
// App.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { UserProvider } from './UserContext';
import UserProfile from './UserProfile';

const App = () => {
  return (
    <UserProvider>
      <View style={styles.container}>
        <Text style={styles.title}>React Native useContext Example</Text>
        <UserProfile />
      </View>
    </UserProvider>
  );
};

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    justifyContent: 'center', 
    alignItems: 'center' 
  },
  title: { 
    fontSize: 20, 
    fontWeight: 'bold', 
    marginBottom: 20 
  },
});

export default App;

---
Folder: C:\Users\porma\Desktop\sisa.ui\app
File: ConfigScreen.js
Content:
// app/config.js (o app/config/index.js)

import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Button,
  Alert,
  TextInput,
  TouchableOpacity,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { BASE_URL } from '../src/config/index';

export default function ConfigScreen() {
  const router = useRouter();

  const [userId, setUserId] = useState(null);

  // Datos de configuraciÃ³n
  const [configDetails, setConfigDetails] = useState(null);

  // Modo ediciÃ³n
  const [editConfig, setEditConfig] = useState(false);

  // Formulario
  const [configForm, setConfigForm] = useState({
    role: '',
    view_type: '',
    theme: '',
    font_size: '',
  });

  // Cargar userId de AsyncStorage
  useEffect(() => {
    const loadUserData = async () => {
      try {
        const storedUserId = await AsyncStorage.getItem('user_id');
        if (storedUserId) setUserId(storedUserId);
      } catch (error) {
        console.log('Error al cargar user_id:', error);
      }
    };
    loadUserData();
  }, []);

  // Cargar configuraciÃ³n
  const loadConfig = async () => {
    if (!userId) return;
    const token = await AsyncStorage.getItem('token');
    if (!token) return;

    try {
      const configResponse = await fetch(
        `${BASE_URL}/user_configurations/${userId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      if (configResponse.ok) {
        const configData = await configResponse.json();
        const configuration = configData.configuration;
        setConfigDetails(configuration);
        setConfigForm({
          role: configuration.role || '',
          view_type: configuration.view_type || '',
          theme: configuration.theme || '',
          font_size: configuration.font_size || '',
        });
      } else {
        console.error('Error al obtener la configuraciÃ³n');
      }
    } catch (error) {
      console.error('Error en fetch de configuraciÃ³n:', error);
    }
  };

  useEffect(() => {
    loadConfig();
  }, [userId]);

  // Guardar cambios en configuraciÃ³n (PUT)
  const handleConfigSave = async () => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_configurations`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          role: configForm.role,
          view_type: configForm.view_type,
          theme: configForm.theme,
          font_size: configForm.font_size,
        }),
      });
      if (response.ok) {
        setConfigDetails({ ...configDetails, ...configForm });
        setEditConfig(false);
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error actualizando configuraciÃ³n');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.subtitle}>ConfiguraciÃ³n</Text>

      {configDetails ? (
        <View style={styles.dataContainer}>
          {editConfig ? (
            <>
              <TextInput
                style={styles.input}
                value={configForm.role}
                onChangeText={(text) => setConfigForm({ ...configForm, role: text })}
                placeholder="Rol"
              />
              <TextInput
                style={styles.input}
                value={configForm.view_type}
                onChangeText={(text) => setConfigForm({ ...configForm, view_type: text })}
                placeholder="Tipo de vista"
              />
              <TextInput
                style={styles.input}
                value={configForm.theme}
                onChangeText={(text) => setConfigForm({ ...configForm, theme: text })}
                placeholder="Tema"
              />
              <TextInput
                style={styles.input}
                value={configForm.font_size}
                onChangeText={(text) => setConfigForm({ ...configForm, font_size: text })}
                placeholder="TamaÃ±o de fuente"
              />
              <Button title="Guardar ConfiguraciÃ³n" onPress={handleConfigSave} />
            </>
          ) : (
            <>
              <Text style={styles.infoText}>Rol: {configDetails.role}</Text>
              <Text style={styles.infoText}>Tipo de vista: {configDetails.view_type}</Text>
              <Text style={styles.infoText}>Tema: {configDetails.theme}</Text>
              <Text style={styles.infoText}>TamaÃ±o de fuente: {configDetails.font_size}</Text>

              <TouchableOpacity
                style={styles.editButton}
                onPress={() => setEditConfig(true)}
              >
                <Text style={styles.editButtonText}>Editar ConfiguraciÃ³n</Text>
              </TouchableOpacity>
            </>
          )}
        </View>
      ) : (
        <Text style={styles.infoText}>Cargando configuraciÃ³n...</Text>
      )}

    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  subtitle: {
    fontSize: 22,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  dataContainer: {
    backgroundColor: '#f5f5f5',
    padding: 15,
    borderRadius: 10,
    marginBottom: 20,
    justifyContent: 'center',
  },
  infoText: { fontSize: 18, marginVertical: 5 },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 8,
    borderRadius: 5,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  editButton: {
    backgroundColor: '#007BFF',
    borderRadius: 10,
    padding: 15,
    marginTop: 10,
    alignItems: 'center',
  },
  editButtonText: {
    color: '#fff',
    fontSize: 18,
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app
File: home.js
Content:
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { useRouter } from 'expo-router';

export default function Menu () {
  const router = useRouter();

  // Define las secciones del sistema; en este ejemplo "Perfil y ConfiguraciÃ³n" es una sola secciÃ³n.
  const menuItems = [
    { title: 'Dashboard', route: './dashboard' },
    { title: 'Clientes', route: './clients/ClientsScreen' },
    { title: 'Productos / Servicios', route: './products' },
    { title: 'Carpetas', route: './folders' },
    { title: 'Trabajos', route: './jobs' },
    { title: 'Ventas', route: './sales' },
    { title: 'Gastos', route: './expenses' },
    { title: 'Citas', route: './appointments' },
    { title: 'Notificaciones', route: './notifications' },
    { title: 'Cajas de Dinero', route: './cashboxes' },
    { title: 'Cierres Contables', route: './accounting_closings' },
    { title: 'Perfil', route: './ProfileScreen' },
    { title: 'ConfiguraciÃ³n', route: './ConfigScreen' },
  ];

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>MenÃº Principal</Text>
      {menuItems.map((item, index) => (
        <TouchableOpacity
          key={index}
          style={styles.menuItem}
          onPress={() => router.push(item.route)}
        >
          <Text style={styles.menuText}>{item.title}</Text>
        </TouchableOpacity>
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f2f2f2'
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center'
  },
  menuItem: {
    backgroundColor: '#007BFF',
    paddingVertical: 15,
    paddingHorizontal: 10,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center'
  },
  menuText: {
    color: 'white',
    fontSize: 18,
  }
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app
File: index.js
Content:
import React, { useEffect } from 'react';
import { View, Text, StyleSheet, Image, Linking, TouchableOpacity } from 'react-native';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import logo from '../assets/images/logo.png';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from '../src/config/index';




export default function SplashScreen() {
  const router = useRouter();

  useEffect(() => {
    const checkProfile = async () => {
      const token = await AsyncStorage.getItem('token');
      if (token) {
        try {
          // USAMOS BASE_URL
          const response = await fetch(`${BASE_URL}/profile`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json',
            },
          });

          if (response.ok) {
            const data = await response.json();
            // Extraemos los datos del usuario
            const { id, username, email } = data.user;
            // Guardamos en AsyncStorage
            await AsyncStorage.setItem('user_id', id.toString());
            await AsyncStorage.setItem('username', username);
            await AsyncStorage.setItem('email', email);

            router.replace('./home');
          } else {
            await AsyncStorage.removeItem('token');
            router.replace('./login/login');
          }
        } catch (error) {
          console.log('Error:', error);
          await AsyncStorage.removeItem('token');
          router.replace('./login/login');
        }
      } else {
        router.replace('./login/login');
      }
    };

    setTimeout(checkProfile, 1000);
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sistema de GestiÃ³n</Text>
      <Image source={logo} style={styles.logo} />

      <TouchableOpacity onPress={() => Linking.openURL('https://www.privacypolicies.com/live/a987d28b-ea26-4d75-97fb-3518c54598b0')}>
        <Text style={{ color: 'blue' }}>PolÃ­tica de Privacidad</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#2f273e', // Color de fondo
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: { 
    fontSize: 24, 
    fontWeight: 'bold', 
    marginBottom: 20,
    color:'#ffffff'
  },
  logo: {
    width: '90%',
    resizeMode: 'contain',
  },
});
---
Folder: C:\Users\porma\Desktop\sisa.ui\app
File: output.txt
Content:
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app
File: home.js
Content:
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { useRouter } from 'expo-router';

const Menu = () => {
  const router = useRouter();

  // Define las secciones del sistema; en este ejemplo "Perfil y ConfiguraciÃƒÂ³n" es una sola secciÃƒÂ³n.
  const menuItems = [
    { title: 'Dashboard', route: './dashboard' },
    { title: 'Clientes', route: './clients/ClientsScreen' },
    { title: 'Productos / Servicios', route: './products' },
    { title: 'Carpetas', route: './folders' },
    { title: 'Trabajos', route: './jobs' },
    { title: 'Ventas', route: './sales' },
    { title: 'Gastos', route: './expenses' },
    { title: 'Citas', route: './appointments' },
    { title: 'Notificaciones', route: './notifications' },
    { title: 'Cajas de Dinero', route: './cashboxes' },
    { title: 'Cierres Contables', route: './accounting_closings' },
    { title: 'Perfil y ConfiguraciÃƒÂ³n', route: './profile' },
  ];

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>MenÃƒÂº Principal</Text>
      {menuItems.map((item, index) => (
        <TouchableOpacity
          key={index}
          style={styles.menuItem}
          onPress={() => router.push(item.route)}
        >
          <Text style={styles.menuText}>{item.title}</Text>
        </TouchableOpacity>
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f2f2f2'
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center'
  },
  menuItem: {
    backgroundColor: '#007BFF',
    paddingVertical: 15,
    paddingHorizontal: 10,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center'
  },
  menuText: {
    color: 'white',
    fontSize: 18,
  }
});

export default Menu;


---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app
File: index.js
Content:
import React, { useEffect } from 'react';
import { View, Text, StyleSheet, Image } from 'react-native';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import logo from '../assets/images/logo.png';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from './config/index';

const SplashScreen = () => {
  const router = useRouter();

  useEffect(() => {
    const checkProfile = async () => {
      const token = await AsyncStorage.getItem('token');
      if (token) {
        try {
          // USAMOS BASE_URL
          const response = await fetch(`${BASE_URL}/profile`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json',
            },
          });

          if (response.ok) {
            const data = await response.json();
            // Extraemos los datos del usuario
            const { id, username, email } = data.user;
            // Guardamos en AsyncStorage
            await AsyncStorage.setItem('user_id', id.toString());
            await AsyncStorage.setItem('username', username);
            await AsyncStorage.setItem('email', email);

            router.replace('./home');
          } else {
            await AsyncStorage.removeItem('token');
            router.replace('./login/login');
          }
        } catch (error) {
          console.log('Error:', error);
          await AsyncStorage.removeItem('token');
          router.replace('./login/login');
        }
      } else {
        router.replace('./login/login');
      }
    };

    setTimeout(checkProfile, 1000);
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sistema de GestiÃƒÂ³n</Text>
      <Image source={logo} style={styles.logo} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#2f273e', // Color de fondo
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: { 
    fontSize: 24, 
    fontWeight: 'bold', 
    marginBottom: 20,
    color:'#ffffff'
  },
  logo: {
    width: '90%',
    resizeMode: 'contain',
  },
});

export default SplashScreen;

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app
File: output.txt
Content:

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app
File: profile.js
Content:
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Button,
  Alert,
  Image,
  TextInput,
  TouchableOpacity,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { BASE_URL } from './config/index';
import { pickAndProcessImage, uploadImage } from './utils/imageUtils';

const Home = () => {
  const router = useRouter();

  // Datos bÃƒÂ¡sicos desde AsyncStorage
  const [userData, setUserData] = useState({
    user_id: null,
    username: null,
    email: null,
  });

  // Datos obtenidos vÃƒÂ­a API
  const [profileDetails, setProfileDetails] = useState(null);
  const [configDetails, setConfigDetails] = useState(null);
  // Imagen obtenida de la API
  const [fileData, setFileData] = useState(null);

  // Modo ediciÃƒÂ³n para perfil y configuraciÃƒÂ³n
  const [editProfile, setEditProfile] = useState(false);
  const [editConfig, setEditConfig] = useState(false);

  // Formularios para editar
  const [profileForm, setProfileForm] = useState({
    full_name: '',
    phone: '',
    address: '',
    cuit: '',
    profile_file_id: '',
  });
  const [configForm, setConfigForm] = useState({
    role: '',
    view_type: '',
    theme: '',
    font_size: '',
  });

  // Cargar datos bÃƒÂ¡sicos del usuario
  useEffect(() => {
    const loadUserData = async () => {
      try {
        const user_id = await AsyncStorage.getItem('user_id');
        const username = await AsyncStorage.getItem('username');
        const email = await AsyncStorage.getItem('email');
        setUserData({ user_id, username, email });
      } catch (error) {
        console.log('Error al cargar datos del usuario:', error);
      }
    };
    loadUserData();
  }, []);

  // FunciÃƒÂ³n para cargar perfil y configuraciÃƒÂ³n
  const loadUserDetails = async () => {
    if (userData.user_id) {
      const token = await AsyncStorage.getItem('token');
      if (!token) return;
      // Obtener perfil
      try {
        const profileResponse = await fetch(
          `${BASE_URL}/user_profile/${userData.user_id}`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        if (profileResponse.ok) {
          const profileData = await profileResponse.json();
          // Extraer el objeto profile (ya que el JSON estÃƒÂ¡ dentro de profile)
          const profile = profileData.profile;
          setProfileDetails(profile);
          setProfileForm({
            full_name: profile.full_name || '',
            phone: profile.phone || '',
            address: profile.address || '',
            cuit: profile.cuit || '',
            profile_file_id: profile.profile_file_id
              ? profile.profile_file_id.toString()
              : '',
          });
        } else {
          console.error('Error al obtener el perfil');
        }
      } catch (error) {
        console.error('Error en fetch de perfil:', error);
      }
      // Obtener configuraciÃƒÂ³n
      try {
        const configResponse = await fetch(
          `${BASE_URL}/user_configurations/${userData.user_id}`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        if (configResponse.ok) {
          const configData = await configResponse.json();
          // Extraer el objeto configuration (ya que el JSON estÃƒÂ¡ dentro de configuration)
          const configuration = configData.configuration;
          setConfigDetails(configuration);
          setConfigForm({
            role: configuration.role || '',
            view_type: configuration.view_type || '',
            theme: configuration.theme || '',
            font_size: configuration.font_size || '',
          });
        } else {
          console.error('Error al obtener la configuraciÃƒÂ³n');
        }
      } catch (error) {
        console.error('Error en fetch de configuraciÃƒÂ³n:', error);
      }
    }
  };

  useEffect(() => {
    loadUserDetails();
  }, [userData.user_id]);

  // Obtener archivo (imagen) a travÃƒÂ©s de la API usando el id dinÃƒÂ¡mico del perfil
  useEffect(() => {
    const loadFile = async () => {
      const token = await AsyncStorage.getItem('token');
      if (!token) return;
      if (profileDetails?.profile_file_id) {
        try {
          const response = await fetch(
            `${BASE_URL}/get_file?file_id=${profileDetails.profile_file_id}`,
            { headers: { Authorization: `Bearer ${token}` } }
          );
          if (response.ok) {
            const blob = await response.blob();
            const reader = new FileReader();
            reader.onloadend = () => {
              setFileData(reader.result);
            };
            reader.readAsDataURL(blob);
          } else {
            console.error('Error al obtener el archivo:', response.status);
          }
        } catch (error) {
          console.error('Error en fetch del archivo:', error);
        }
      }
    };
    loadFile();
  }, [profileDetails]);

  // FunciÃƒÂ³n para tomar foto, subirla y actualizar el perfil usando las utilidades
  const handleTakePhoto = async () => {
    Alert.alert(
      'Seleccionar imagen',
      'Elige una opciÃƒÂ³n',
      [
        {
          text: 'CÃƒÂ¡mara',
          onPress: async () => {
            const localUri = await pickAndProcessImage(true);
            if (localUri) {
              await uploadPhoto(localUri);
            }
          },
        },
        {
          text: 'GalerÃƒÂ­a',
          onPress: async () => {
            const localUri = await pickAndProcessImage(false);
            if (localUri) {
              await uploadPhoto(localUri);
            }
          },
        },
        { text: 'Cancelar', style: 'cancel' },
      ]
    );
  };

  // FunciÃƒÂ³n modificada para subir la imagen utilizando uploadImage de utils/imageUtils.ts
  const uploadPhoto = async (localUri) => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const fileId = await uploadImage(localUri, token);
      if (fileId) {
        // Actualizar el perfil usando la URL sin id (el API toma el id del token)
        const updateResponse = await fetch(
          `${BASE_URL}/user_profile`,
          {
            method: 'PUT',
            headers: {
              Authorization: `Bearer ${token}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              full_name: profileForm.full_name,
              phone: profileForm.phone,
              address: profileForm.address,
              cuit: profileForm.cuit,
              profile_file_id: fileId,
            }),
          }
        );

        if (updateResponse.ok) {
          setFileData(localUri);
          // Refrescar toda la informaciÃƒÂ³n del usuario
          loadUserDetails();
        } else {
          const errData = await updateResponse.json();
          Alert.alert('Error', errData.error || 'Error actualizando perfil');
        }
      } else {
        Alert.alert('Error', 'Error al subir archivo');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  const handleLogout = async () => {
    try {
      await AsyncStorage.removeItem('token');
      await AsyncStorage.removeItem('user_id');
      await AsyncStorage.removeItem('username');
      await AsyncStorage.removeItem('email');
      Alert.alert('SesiÃƒÂ³n cerrada');
      router.replace('./login/login');
    } catch (error) {
      console.log('Error al cerrar sesiÃƒÂ³n:', error);
    }
  };

  // Guardar cambios en perfil vÃƒÂ­a PUT (token enviado en el header)
  const handleProfileSave = async () => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const response = await fetch(
        `${BASE_URL}/user_profile`,
        {
          method: 'PUT',
          headers: {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            full_name: profileForm.full_name,
            phone: profileForm.phone,
            address: profileForm.address,
            cuit: profileForm.cuit,
            profile_file_id: profileForm.profile_file_id === '' 
              ? null 
              : parseInt(profileForm.profile_file_id),
          }),
        }
      );
      if (response.ok) {
        setProfileDetails({ ...profileDetails, ...profileForm });
        setEditProfile(false);
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error actualizando perfil');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  // Guardar cambios en configuraciÃƒÂ³n vÃƒÂ­a PUT (token enviado en el header)
  const handleConfigSave = async () => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const response = await fetch(
        `${BASE_URL}/user_configurations`,
        {
          method: 'PUT',
          headers: {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            role: configForm.role,
            view_type: configForm.view_type,
            theme: configForm.theme,
            font_size: configForm.font_size,
          }),
        }
      );
      if (response.ok) {
        setConfigDetails({ ...configDetails, ...configForm });
        setEditConfig(false);
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error actualizando configuraciÃƒÂ³n');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.subtitle}>
        Perfil
        <TouchableOpacity onPress={() => setEditProfile(!editProfile)}>
          <Text style={styles.editIcon}> Ã¢Å“ï¿½Ã¯Â¸ï¿½</Text>
        </TouchableOpacity>
      </Text>

      {profileDetails ? (
        <View style={styles.dataContainer}>
          {fileData ? (
            <View style={styles.profileImageContainer}>
              <Image source={{ uri: fileData }} style={styles.fileImage} />
              {/* BotÃƒÂ³n en la esquina inferior derecha, por encima de la imagen */}
              <TouchableOpacity
                style={styles.cameraButtonOnImage}
                onPress={handleTakePhoto}
              >
                <Text style={styles.cameraIconText}>Ã°Å¸â€œÂ·</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <View style={[styles.profileImageContainer, styles.defaultImage]}>
              {/* Si no hay imagen, el botÃƒÂ³n se centra en el cÃƒÂ­rculo */}
              <TouchableOpacity
                style={styles.cameraButtonNoImage}
                onPress={handleTakePhoto}
              >
                <Text style={styles.cameraIconText}>Ã°Å¸â€œÂ·</Text>
              </TouchableOpacity>
            </View>
          )}

          <Text style={styles.infoText}>Username: {userData.username}</Text>
          <Text style={styles.infoText}>Email: {userData.email}</Text>
          {editProfile ? (
            <>
              <TextInput
                style={styles.input}
                value={profileForm.full_name}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, full_name: text })
                }
                placeholder="Nombre completo"
              />
              <TextInput
                style={styles.input}
                value={profileForm.phone}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, phone: text })
                }
                placeholder="TelÃƒÂ©fono"
                keyboardType="phone-pad"
              />
              <TextInput
                style={styles.input}
                value={profileForm.address}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, address: text })
                }
                placeholder="DirecciÃƒÂ³n"
              />
              <TextInput
                style={styles.input}
                value={profileForm.cuit}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, cuit: text })
                }
                placeholder="CUIT"
                keyboardType="numeric"
              />
              <Button title="Guardar Perfil" onPress={handleProfileSave} />
            </>
          ) : (
            <>
              <Text style={styles.infoText}>
                Nombre: {profileDetails.full_name}
              </Text>
              <Text style={styles.infoText}>
                TelÃƒÂ©fono: {profileDetails.phone}
              </Text>
              <Text style={styles.infoText}>
                DirecciÃƒÂ³n: {profileDetails.address}
              </Text>
              <Text style={styles.infoText}>CUIT: {profileDetails.cuit}</Text>
            </>
          )}
        </View>
      ) : (
        <Text style={styles.infoText}>Cargando perfil...</Text>
      )}

      <Text style={styles.subtitle}>
        ConfiguraciÃƒÂ³n
        <TouchableOpacity onPress={() => setEditConfig(!editConfig)}>
          <Text style={styles.editIcon}> Ã¢Å“ï¿½Ã¯Â¸ï¿½</Text>
        </TouchableOpacity>
      </Text>
      {configDetails ? (
        <View style={styles.dataContainer}>
          {editConfig ? (
            <>
              <TextInput
                style={styles.input}
                value={configForm.role}
                onChangeText={(text) =>
                  setConfigForm({ ...configForm, role: text })
                }
                placeholder="Rol"
              />
              <TextInput
                style={styles.input}
                value={configForm.view_type}
                onChangeText={(text) =>
                  setConfigForm({ ...configForm, view_type: text })
                }
                placeholder="Tipo de vista"
              />
              <TextInput
                style={styles.input}
                value={configForm.theme}
                onChangeText={(text) =>
                  setConfigForm({ ...configForm, theme: text })
                }
                placeholder="Tema"
              />
              <TextInput
                style={styles.input}
                value={configForm.font_size}
                onChangeText={(text) =>
                  setConfigForm({ ...configForm, font_size: text })
                }
                placeholder="TamaÃƒÂ±o de fuente"
              />
              <Button title="Guardar ConfiguraciÃƒÂ³n" onPress={handleConfigSave} />
            </>
          ) : (
            <>
              <Text style={styles.infoText}>Rol: {configDetails.role}</Text>
              <Text style={styles.infoText}>
                Tipo de vista: {configDetails.view_type}
              </Text>
              <Text style={styles.infoText}>Tema: {configDetails.theme}</Text>
              <Text style={styles.infoText}>
                TamaÃƒÂ±o de fuente: {configDetails.font_size}
              </Text>
            </>
          )}
        </View>
      ) : (
        <Text style={styles.infoText}>Cargando configuraciÃƒÂ³n...</Text>
      )}

      <Button title="Cerrar SesiÃƒÂ³n" onPress={handleLogout} />
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 10 },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 20,
    marginBottom: 10,
  },
  dataContainer: {
    backgroundColor: '#f5f5f5',
    padding: 15,
    borderRadius: 10,
    marginBottom: 20,
    justifyContent: 'center',
  },
  infoText: { fontSize: 18, marginVertical: 5 },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 5,
    borderRadius: 5,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  editIcon: {
    fontSize: 18,
    marginLeft: 10,
    color: '#007BFF',
  },
  // Contenedor de la imagen: se permite overflow visible para que el botÃƒÂ³n pueda salir
  profileImageContainer: {
    width: 200,
    height: 200,
    borderRadius: 100,
    alignItems: 'center',
    justifyContent: 'center',
    alignSelf: 'center',
    marginBottom: 15,
    overflow: 'visible',
    position: 'relative',
  },
  // Imagen circular con borderRadius
  fileImage: {
    width: 200,
    height: 200,
    resizeMode: 'cover',
    borderRadius: 100,
  },
  defaultImage: {
    backgroundColor: 'blue',
  },
  // BotÃƒÂ³n de cÃƒÂ¡mara cuando hay imagen: se posiciona fuera del contenedor
  cameraButtonOnImage: {
    position: 'absolute',
    bottom: -10,
    right: -10,
    backgroundColor: 'rgba(0,0,0,0.5)',
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2,
  },
  // BotÃƒÂ³n de cÃƒÂ¡mara cuando NO hay imagen: centrado en el contenedor
  cameraButtonNoImage: {
    alignSelf: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cameraIconText: {
    fontSize: 30,
    color: 'white',
  },
});

export default Home;

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\clients
File: addClient.js
Content:
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Alert,
  ScrollView,
  Button,
  Image,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { pickAndProcessImage, uploadImage } from '../utils/imageUtils';
import { BASE_URL } from '../config/index';

const AddClient = () => {
  const router = useRouter();
  const [form, setForm] = useState({
    business_name: '',
    tax_id: '',
    email: '',
    brand_file_id: null,
    phone: '',
    address: '',
  });
  const [uploading, setUploading] = useState(false);
  const [localImageUri, setLocalImageUri] = useState(null);

  const handlePickImage = () => {
    Alert.alert(
      'Seleccionar imagen',
      'Elige una opciÃƒÂ³n',
      [
        {
          text: 'CÃƒÂ¡mara',
          onPress: async () => {
            const localUri = await pickAndProcessImage(true);
            if (localUri) {
              await handleUploadPhoto(localUri);
            }
          },
        },
        {
          text: 'GalerÃƒÂ­a',
          onPress: async () => {
            const localUri = await pickAndProcessImage(false);
            if (localUri) {
              await handleUploadPhoto(localUri);
            }
          },
        },
        { text: 'Cancelar', style: 'cancel' },
      ]
    );
  };

  const handleUploadPhoto = async (localUri) => {
    setUploading(true);
    try {
      const token = await AsyncStorage.getItem('token');
      if (!token) return;
      const fileId = await uploadImage(localUri, token);
      if (fileId) {
        setForm({ ...form, brand_file_id: fileId });
        setLocalImageUri(localUri);
      } else {
        Alert.alert('Error', 'Error al subir la imagen');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setUploading(false);
    }
  };

  const handleSave = async () => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/clients`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(form),
      });
      if (response.ok) {
        Alert.alert('Ãƒâ€°xito', 'Cliente creado correctamente');
        router.push('./ClientsScreen');
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error creando el cliente');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>Agregar Cliente</Text>
      {(localImageUri || form.brand_file_id) && (
        <Image
          source={{
            uri: localImageUri || `${BASE_URL}/get_file?file_id=${form.brand_file_id}`,
          }}
          style={styles.previewImage}
        />
      )}
      <TouchableOpacity style={styles.imageButton} onPress={handlePickImage}>
        <Text style={styles.imageButtonText}>
          {localImageUri || form.brand_file_id ? 'Cambiar Logo' : 'Agregar Logo'}
        </Text>
      </TouchableOpacity>
      <TextInput
        style={styles.input}
        placeholder="RazÃƒÂ³n Social"
        value={form.business_name}
        onChangeText={(text) => setForm({ ...form, business_name: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="CUIT / Tax ID"
        value={form.tax_id}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, tax_id: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={form.email}
        keyboardType="email-address"
        onChangeText={(text) => setForm({ ...form, email: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="TelÃƒÂ©fono"
        value={form.phone}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, phone: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="DirecciÃƒÂ³n"
        value={form.address}
        onChangeText={(text) => setForm({ ...form, address: text })}
      />
      <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
        <Text style={styles.saveButtonText}>Crear Cliente</Text>
      </TouchableOpacity>
      <Button title="Cancelar" onPress={() => router.push('./ClientsScreen')} />
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, backgroundColor: '#fff' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20, textAlign: 'center' },
  input: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 15,
    borderRadius: 5,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  saveButton: {
    backgroundColor: '#007BFF',
    padding: 15,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  imageButton: {
    backgroundColor: '#28A745',
    padding: 10,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  imageButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  previewImage: {
    width: 200,
    aspectRatio: 1,
    borderRadius: 100,
    alignSelf: 'center',
    marginBottom: 15,
  },
});

export default AddClient;

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\clients
File: ClientItem.js
Content:
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  Image,
  StyleSheet,
  TouchableOpacity,
  Alert,
  LayoutAnimation,
  UIManager,
  Platform
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { BASE_URL } from '../config/index';

/**
 * Componente controlado para mostrar la tarjeta de cliente.
 * Recibe:
 * - item: datos del cliente.
 * - expanded: booleano que indica si el item estÃƒÂ¡ expandido.
 * - onToggle: funciÃƒÂ³n que se invoca al pulsar la tarjeta para cambiar el estado expandido.
 * - onDelete: callback para eliminar.
 * - onEdit: callback para editar.
 */
export default function ClientItem({ item, expanded, onToggle, onDelete, onEdit }) {
  const [imageData, setImageData] = useState(null);

  // Habilitar animaciones en Android
  useEffect(() => {
    if (Platform.OS === 'android') {
      UIManager.setLayoutAnimationEnabledExperimental &&
        UIManager.setLayoutAnimationEnabledExperimental(true);
    }
  }, []);

  // Cargar la imagen del cliente, si existe
  useEffect(() => {
    const loadFile = async () => {
      if (!item.brand_file_id) return;
      const token = await AsyncStorage.getItem('token');
      if (!token) return;
      try {
        const response = await fetch(
          `${BASE_URL}/get_file?file_id=${item.brand_file_id}`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        if (response.ok) {
          const blob = await response.blob();
          const reader = new FileReader();
          reader.onloadend = () => setImageData(reader.result);
          reader.readAsDataURL(blob);
        } else {
          console.error('Error al obtener el archivo:', response.status);
        }
      } catch (error) {
        console.error('Error en fetch del archivo:', error);
      }
    };
    loadFile();
  }, [item.brand_file_id]);

  // Al pulsar la tarjeta, alterna el estado expandido
  const handleToggle = () => {
    if (Platform.OS !== 'web' && LayoutAnimation && LayoutAnimation.configureNext) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    }
    onToggle(item.id);
  };

  // Ajustar tamaÃƒÂ±o del avatar segÃƒÂºn si estÃƒÂ¡ expandido
  const avatarSize = expanded ? 80 : 50;
  // Se muestra el nombre del negocio
  const titleText = item.business_name;

  return (
    <TouchableOpacity onPress={handleToggle} activeOpacity={0.8}>
      <View style={styles.itemContainer}>
        {/* Cabecera: TÃƒÂ­tulo a la izquierda, avatar a la derecha */}
        <View style={styles.headerRow}>
          <Text style={styles.companyName}>{titleText}</Text>
          <View style={[styles.avatarContainer, { width: avatarSize, height: avatarSize }]}>
            {imageData ? (
              <Image source={{ uri: imageData }} style={styles.avatarImage} />
            ) : (
              <View style={styles.avatarPlaceholder} />
            )}
          </View>
        </View>

        {/* Datos adicionales solo si expandido */}
        {expanded && (
          <>
            <Text style={styles.itemText}>CUIT: {item.tax_id}</Text>
            <Text style={styles.itemText}>eMail: {item.email}</Text>
            <Text style={styles.itemText}>DirecciÃƒÂ³n: {item.address}</Text>
            <Text style={styles.itemText}>TelÃƒÂ©fono: {item.phone}</Text>
          </>
        )}

        {/* Botonera a todo el ancho, visible solo si expandido */}
        {expanded && (
          <View style={styles.buttonContainer}>
            <TouchableOpacity style={styles.button} onPress={() => onEdit(item.id)}>
              <Text style={styles.buttonText}>Editar</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.button, styles.deleteButton]}
              onPress={() =>
                Alert.alert(
                  'Confirmar',
                  'Ã‚Â¿EstÃƒÂ¡s seguro de eliminar este cliente?',
                  [
                    { text: 'Cancelar', style: 'cancel' },
                    {
                      text: 'Eliminar',
                      style: 'destructive',
                      onPress: () => onDelete(item.id),
                    },
                  ]
                )
              }
            >
              <Text style={styles.buttonText}>Eliminar</Text>
            </TouchableOpacity>
          </View>
        )}
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  itemContainer: {
    width: '100%',
    backgroundColor: '#E2E2FA',
    borderRadius: 10,
    padding: 15,
    marginBottom: 15,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  companyName: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  avatarContainer: {
    overflow: 'hidden',
    borderRadius: 999,
    backgroundColor: '#007BFF',
  },
  avatarImage: {
    width: '100%',
    height: '100%',
    borderRadius: 999,
  },
  avatarPlaceholder: {
    flex: 1,
    borderRadius: 999,
    backgroundColor: '#007BFF',
  },
  itemText: {
    fontSize: 16,
    marginTop: 5,
  },
  buttonContainer: {
    width: '100%',
    flexDirection: 'row',
    marginTop: 10,
  },
  button: {
    flex: 1,
    backgroundColor: '#007BFF',
    padding: 15,
    borderRadius: 5,
    marginRight: 10,
    alignItems: 'center',
  },
  deleteButton: {
    backgroundColor: '#FF3333',
    marginRight: 0,
  },
  buttonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\clients
File: clientList.js
Content:
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  Alert,
  ActivityIndicator,
  Platform,
  UIManager,
  LayoutAnimation,
  TextInput,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import ClientItem from './ClientItem';
import { BASE_URL } from '../config/index';
import Fuse from 'fuse.js';

export default function ClientList() {
  const router = useRouter();
  const [clients, setClients] = useState([]);
  const [filteredClients, setFilteredClients] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  // Estado para almacenar el id del item actualmente expandido (null si ninguno)
  const [expandedItemId, setExpandedItemId] = useState(null);

  // Activar animaciones en Android
  useEffect(() => {
    if (Platform.OS === 'android') {
      UIManager.setLayoutAnimationEnabledExperimental &&
        UIManager.setLayoutAnimationEnabledExperimental(true);
    }
  }, []);

  // Cargar clientes desde la API
  const loadClients = async () => {
    setLoading(true);
    const token = await AsyncStorage.getItem('token');
    if (!token) {
      setLoading(false);
      return;
    }
    try {
      const response = await fetch(`${BASE_URL}/clients`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const data = await response.json();
        const allClients = data.clients || data;
        setClients(allClients);
        setFilteredClients(allClients);
      } else {
        Alert.alert('Error', 'No se pudieron obtener los clientes');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadClients();
  }, []);

  // Configurar Fuse para bÃƒÂºsqueda avanzada (fuzzy search)
  useEffect(() => {
    if (searchQuery.trim() === '') {
      setFilteredClients(clients);
      return;
    }
    const options = {
      keys: ['business_name', 'tax_id', 'email', 'address', 'phone'],
      threshold: 0.4, // Ajusta la sensibilidad de la bÃƒÂºsqueda
      includeScore: true,
    };
    const fuse = new Fuse(clients, options);
    const results = fuse.search(searchQuery);
    const matchedClients = results.map(result => result.item);
    setFilteredClients(matchedClients);
  }, [searchQuery, clients]);

  const handleDelete = async (clientId) => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/clients/${clientId}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        Alert.alert('Cliente eliminado');
        loadClients();
        if (expandedItemId === clientId) {
          setExpandedItemId(null);
        }
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error eliminando el cliente');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  const handleEdit = (clientId) => {
    router.push(`./editClient?id=${clientId}`);
  };

  // Alterna el estado expandido: solo un item se expande a la vez
  const handleToggle = (clientId) => {
    if (Platform.OS !== 'web' && LayoutAnimation && LayoutAnimation.configureNext) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    }
    setExpandedItemId(prev => (prev === clientId ? null : clientId));
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.searchInput}
        placeholder="Buscar clientes..."
        value={searchQuery}
        onChangeText={setSearchQuery}
      />
      {loading ? (
        <ActivityIndicator size="large" color="#007BFF" style={styles.loader} />
      ) : (
        <FlatList
          data={filteredClients}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <ClientItem
              item={item}
              expanded={expandedItemId === item.id}
              onToggle={handleToggle}
              onDelete={handleDelete}
              onEdit={handleEdit}
            />
          )}
          contentContainerStyle={styles.listContainer}
          ListEmptyComponent={<Text>No hay clientes disponibles.</Text>}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    width: '100%',  // Se ocupa todo el ancho de la pantalla
    backgroundColor: '#fff',
    padding: 20,
  },
  searchInput: {
    height: 40,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    paddingHorizontal: 10,
  },
  listContainer: { 
    marginTop: 20,
  },
  loader: { 
    marginTop: 20,
  },
});

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\clients
File: ClientsScreen.js
Content:
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import ClientList from './clientList';
import { useRouter } from 'expo-router';

export default function ClientsScreen() {
  const router = useRouter();

  const handleAddClient = () => {
    router.push('./addClient');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Lista de Clientes</Text>
      <ClientList />
      <TouchableOpacity style={styles.floatingButton} onPress={handleAddClient}>
        <Text style={styles.floatingButtonText}>+</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#fff',
    padding: 20 
  },
  title: { 
    fontSize: 24, 
    fontWeight: 'bold', 
    marginBottom: 10 
  },
  floatingButton: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    backgroundColor: '#007BFF',
    width: 60,
    height: 60,
    borderRadius: 30,
    alignItems: 'center',
    justifyContent: 'center',
    // Sombra para Android e iOS
    elevation: 5,
    shadowColor: '#000',
    shadowOpacity: 0.3,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 2,
  },
  floatingButtonText: {
    fontSize: 30,
    color: '#fff',
    marginTop: -4, // Ajuste fino para centrar el '+'
  },
});

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\clients
File: editClient.js
Content:
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Alert,
  ActivityIndicator,
  Button,
  ScrollView,
  Image,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { useRoute } from '@react-navigation/native';
import { pickAndProcessImage, uploadImage } from '../utils/imageUtils';
import { BASE_URL } from '../config/index';

const EditClient = () => {
  const router = useRouter();
  const route = useRoute();
  const { id } = route.params; // Obtenemos el id del cliente

  const [loading, setLoading] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [localImageUri, setLocalImageUri] = useState(null);
  const [form, setForm] = useState({
    business_name: '',
    tax_id: '',
    email: '',
    brand_file_id: null,
    phone: '',
    address: '',
  });

  // Cargar datos del cliente en modo ediciÃƒÂ³n
  const loadClient = async () => {
    if (!id) return;
    setLoading(true);
    try {
      const token = await AsyncStorage.getItem('token');
      if (!token) return;
      const response = await fetch(`${BASE_URL}/clients/${id}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const data = await response.json();
        const client = data.client;
        setForm({
          business_name: client.business_name || '',
          tax_id: client.tax_id || '',
          email: client.email || '',
          brand_file_id: client.brand_file_id,
          phone: client.phone || '',
          address: client.address || '',
        });
        if (client.brand_file_id) {
          // Actualizamos la imagen local usando la URL basada en BASE_URL
          setLocalImageUri(`${BASE_URL}/get_file?file_id=${client.brand_file_id}`);
        }
      } else {
        Alert.alert('Error', 'No se pudo obtener la informaciÃƒÂ³n del cliente');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (id) {
      loadClient();
    }
  }, [id]);

  // FunciÃƒÂ³n para seleccionar imagen usando la librerÃƒÂ­a de utilidades
  const handlePickImage = () => {
    Alert.alert(
      'Seleccionar imagen',
      'Elige una opciÃƒÂ³n',
      [
        {
          text: 'CÃƒÂ¡mara',
          onPress: async () => {
            const localUri = await pickAndProcessImage(true);
            if (localUri) {
              await handleUploadPhoto(localUri);
            }
          },
        },
        {
          text: 'GalerÃƒÂ­a',
          onPress: async () => {
            const localUri = await pickAndProcessImage(false);
            if (localUri) {
              await handleUploadPhoto(localUri);
            }
          },
        },
        { text: 'Cancelar', style: 'cancel' },
      ]
    );
  };

  // FunciÃƒÂ³n para subir la imagen al servidor utilizando la funciÃƒÂ³n uploadImage de la librerÃƒÂ­a
  const handleUploadPhoto = async (localUri) => {
    setUploading(true);
    try {
      const token = await AsyncStorage.getItem('token');
      if (!token) return;
      const fileId = await uploadImage(localUri, token);
      if (fileId) {
        setForm({ ...form, brand_file_id: fileId });
        setLocalImageUri(localUri);
      } else {
        Alert.alert('Error', 'Error al subir la imagen');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setUploading(false);
    }
  };

  // FunciÃƒÂ³n para guardar (crear o actualizar) el cliente
  const handleSave = async () => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    const url = id ? `${BASE_URL}/clients/${id}` : `${BASE_URL}/clients`;
    const method = id ? 'PUT' : 'POST';
    try {
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(form),
      });
      if (response.ok) {
        Alert.alert('Ãƒâ€°xito', id ? 'Cliente actualizado' : 'Cliente creado');
        router.push('./ClientsScreen');
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error al guardar');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  // FunciÃƒÂ³n para eliminar el cliente
  const handleDelete = async () => {
    if (!id) return;
    Alert.alert(
      'Confirmar',
      'Ã‚Â¿EstÃƒÂ¡ seguro de eliminar este cliente?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Eliminar',
          style: 'destructive',
          onPress: async () => {
            const token = await AsyncStorage.getItem('token');
            if (!token) return;
            try {
              const response = await fetch(`${BASE_URL}/clients/${id}`, {
                method: 'DELETE',
                headers: { Authorization: `Bearer ${token}` },
              });
              if (response.ok) {
                Alert.alert('Ãƒâ€°xito', 'Cliente eliminado');
                router.push('./ClientsScreen');
              } else {
                const errData = await response.json();
                Alert.alert('Error', errData.error || 'Error eliminando el cliente');
              }
            } catch (error) {
              Alert.alert('Error', error.message);
            }
          },
        },
      ]
    );
  };

  if (loading) {
    return (
      <View style={styles.loaderContainer}>
        <ActivityIndicator size="large" color="#007BFF" />
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>{id ? 'Editar Cliente' : 'Agregar Cliente'}</Text>
      {(localImageUri || form.brand_file_id) && (
        <Image
          source={{
            uri: localImageUri || `${BASE_URL}/get_file?file_id=${form.brand_file_id}`,
          }}
          style={styles.previewImage}
        />
      )}
      <TouchableOpacity style={styles.imageButton} onPress={handlePickImage}>
        <Text style={styles.imageButtonText}>
          {localImageUri || form.brand_file_id ? 'Cambiar Logo' : 'Agregar Logo'}
        </Text>
      </TouchableOpacity>

      <TextInput
        style={styles.input}
        placeholder="RazÃƒÂ³n Social"
        value={form.business_name}
        onChangeText={(text) => setForm({ ...form, business_name: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="CUIT / Tax ID"
        value={form.tax_id}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, tax_id: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={form.email}
        keyboardType="email-address"
        onChangeText={(text) => setForm({ ...form, email: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="TelÃƒÂ©fono"
        value={form.phone}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, phone: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="DirecciÃƒÂ³n"
        value={form.address}
        onChangeText={(text) => setForm({ ...form, address: text })}
      />
      <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
        <Text style={styles.saveButtonText}>{id ? 'Actualizar' : 'Crear'}</Text>
      </TouchableOpacity>
      {id && (
        <TouchableOpacity style={styles.deleteButton} onPress={handleDelete}>
          <Text style={styles.deleteButtonText}>Eliminar Cliente</Text>
        </TouchableOpacity>
      )}
      <Button title="Cancelar" onPress={() => router.push('./ClientsScreen')} />
      {uploading && <ActivityIndicator size="large" color="#007BFF" />}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, backgroundColor: '#fff' },
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20, textAlign: 'center' },
  input: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 15,
    borderRadius: 5,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  saveButton: {
    backgroundColor: '#007BFF',
    padding: 15,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  deleteButton: {
    backgroundColor: '#FF3333',
    padding: 15,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  imageButton: {
    backgroundColor: '#28A745',
    padding: 10,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  imageButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  previewImage: {
    width: 200,
    aspectRatio: 1,
    borderRadius: 100,
    alignSelf: 'center',
    marginBottom: 15,
  },
});

export default EditClient;

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\config
File: index.js
Content:
export const BASE_URL = 'https://sistema.depros.com.ar';
export const MAX_FILE_SIZE = 1 * 1024 * 1024; // 1 MB
---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\login
File: forgot-password.js
Content:
import React, { useState } from 'react';
import { View, TextInput, Button, Alert, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from '../config/index';

const ForgotPassword = () => {
  const router = useRouter();
  const [email, setEmail] = useState('');

  const handleForgotPassword = async () => {
    if (!email) {
      Alert.alert('Error', 'Por favor ingresa tu email');
      return;
    }
    try {
      // USAMOS BASE_URL
      const response = await fetch(`${BASE_URL}/forgot_password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });
      const result = await response.json();
      if (response.ok) {
        Alert.alert('Ãƒâ€°xito', result.message || 'Email de recuperaciÃƒÂ³n enviado');
        router.replace('./login');
      } else {
        Alert.alert('Error', result.error || 'Error al enviar la solicitud');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Ingresa tu email"
        style={styles.input}
        value={email}
        keyboardType="email-address"
        onChangeText={setEmail}
      />
      <Button title="Enviar recuperaciÃƒÂ³n" onPress={handleForgotPassword} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  input: { borderWidth: 1, padding: 10, marginBottom: 10 },
});

export default ForgotPassword;

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\login
File: login.js
Content:
import React, { useState } from 'react';
import { View, TextInput, Button, Alert, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from '../config/index';

const Login = () => {
  const router = useRouter();
  const [username, setUsername] = useState('pormauro');
  const [password, setPassword] = useState('123456');

  const handleLogin = async () => {
    if (!username || !password) {
      Alert.alert('Error', 'Ingresa username y contraseÃƒÂ±a');
      return;
    }
    try {
      // USAMOS BASE_URL
      const response = await fetch(`${BASE_URL}/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      });

      if (response.ok) {
        const authHeader = response.headers.get('Authorization');
        const token = authHeader && authHeader.startsWith('Bearer ')
          ? authHeader.split(' ')[1]
          : null;

        if (token) {
          // Guardamos el token en AsyncStorage
          await AsyncStorage.setItem('token', token);

          // Solicitar el perfil del usuario para guardar sus datos
          const profileResponse = await fetch(`${BASE_URL}/profile`, {
            method: 'GET',
            headers: { 
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
          });

          if (profileResponse.ok) {
            const profileData = await profileResponse.json();
            const { id, username: userName, email } = profileData.user;
            await AsyncStorage.setItem('user_id', id.toString());
            await AsyncStorage.setItem('username', userName);
            await AsyncStorage.setItem('email', email);

            // Redirigir a Home
            router.replace('../home');
          } else {
            Alert.alert('Error', 'No se pudo obtener el perfil del usuario');
          }
        } else {
          Alert.alert('Error', 'Token no recibido en el encabezado');
        }
      } else {
        const result = await response.json();
        Alert.alert('Error', result.error || 'Credenciales invÃƒÂ¡lidas');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Username"
        style={styles.input}
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        placeholder="ContraseÃƒÂ±a"
        secureTextEntry
        style={styles.input}
        value={password}
        onChangeText={setPassword}
      />
      <Button title="Ingresar" onPress={handleLogin} />
      <Button title="Registrarse" onPress={() => router.push('./register')} />
      <Button title="OlvidÃƒÂ© mi contraseÃƒÂ±a" onPress={() => router.push('./forgot-password')} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, justifyContent: 'center' },
  input: { borderWidth: 1, padding: 10, marginBottom: 10 },
});

export default Login;

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\login
File: register.js
Content:
import React, { useState } from 'react';
import { View, TextInput, Button, Alert, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from '../config/index';

const Register = () => {
  const router = useRouter();
  const [username, setUsername] = useState('pormauro');
  const [email, setEmail] = useState('pormauro@gmail.com');
  const [password, setPassword] = useState('123456');

  const handleRegister = async () => {
    if (!username || !email || !password) {
      Alert.alert('Error', 'Todos los campos son requeridos');
      return;
    }
    try {
      // USAMOS BASE_URL
      const response = await fetch(`${BASE_URL}/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, email, password }),
      });
      const result = await response.json();
      if (response.ok) {
        Alert.alert(
          'Ãƒâ€°xito',
          result.message || 'Usuario registrado. Revisa tu email para activar la cuenta.'
        );
        router.replace('./login');
      } else {
        Alert.alert('Error', result.error || 'Error en el registro');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Nombre de usuario"
        style={styles.input}
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        placeholder="Correo electrÃƒÂ³nico"
        style={styles.input}
        value={email}
        keyboardType="email-address"
        onChangeText={setEmail}
      />
      <TextInput
        placeholder="ContraseÃƒÂ±a"
        secureTextEntry
        style={styles.input}
        value={password}
        onChangeText={setPassword}
      />
      <Button title="Registrar" onPress={handleRegister} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  input: { borderWidth: 1, padding: 10, marginBottom: 10 },
});

export default Register;

---
Folder: C:/Users/porma/Desktop/movil/202503142041 - copia/sisa/app\utils
File: imageUtils.ts
Content:
// sisa/app/utils/imageUtils.ts

import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import * as FileSystem from 'expo-file-system';
import { Alert } from 'react-native';
import { BASE_URL, MAX_FILE_SIZE } from '../config/index';

/**
 * Solicita permisos para cÃƒÂ¡mara o galerÃƒÂ­a, abre la fuente de imagen
 * y retorna el objeto resultante de ImagePicker.
 * 
 * NOTA: Se omiten 'allowsEditing' y 'aspect' para evitar reinicios/crashes en algunos Android.
 *       Se reduce la calidad a 0.7 (70%) para no generar archivos muy grandes de inicio.
 */
export async function pickImageFromSource(fromCamera: boolean) {
  if (fromCamera) {
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Permiso denegado', 'Se requieren permisos de cÃƒÂ¡mara.');
      return null;
    }
    return await ImagePicker.launchCameraAsync({
      quality: 0.7,
    });
  } else {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Permiso denegado', 'Se requieren permisos de galerÃƒÂ­a.');
      return null;
    }
    return await ImagePicker.launchImageLibraryAsync({
      quality: 0.7,
    });
  }
}

/**
 * Verifica y comprime/redimensiona la imagen HASTA que su tamaÃƒÂ±o sea <= MAX_FILE_SIZE (1MB).
 * Realiza varias "pasadas" reduciendo gradualmente el tamaÃƒÂ±o y la compresiÃƒÂ³n. 
 * Retorna el nuevo URI local de la imagen final bajo 1MB (o lo que defina MAX_FILE_SIZE).
 */
async function ensureUnderMaxSize(
  uri: string,
  originalWidth: number,
  originalHeight: number
): Promise<string> {
  let currentUri = uri;
  let width = originalWidth;
  let height = originalHeight;

  // Hasta 3 intentos para ir reduciendo
  const maxPasses = 3;
  // Empieza con una compresiÃƒÂ³n razonable
  let compressQuality = 0.7;

  for (let attempt = 1; attempt <= maxPasses; attempt++) {
    const fileInfo = await FileSystem.getInfoAsync(currentUri);
    if (!fileInfo.exists || typeof fileInfo.size !== 'number') {
      // Si algo falla, salimos sin forzar
      return currentUri;
    }
    if (fileInfo.size <= MAX_FILE_SIZE) {
      // Ya estamos por debajo (o igual) al lÃƒÂ­mite de 1MB
      return currentUri;
    }
    // Reducir dimensiones de forma aproximada para acercarnos a 1MB
    const ratio = Math.sqrt(MAX_FILE_SIZE / fileInfo.size);
    // Si ratio >= 1, significa que ya estamos "casi" sin necesidad de redimensionar
    // pero igual se comprime un poco mÃƒÂ¡s.
    const newWidth = Math.floor(width * Math.min(ratio, 0.9));
    const newHeight = Math.floor(height * Math.min(ratio, 0.9));

    // Procesar con ImageManipulator
    const manipResult = await ImageManipulator.manipulateAsync(
      currentUri,
      [{ resize: { width: newWidth, height: newHeight } }],
      {
        compress: compressQuality,
        format: ImageManipulator.SaveFormat.JPEG,
      }
    );

    currentUri = manipResult.uri;
    width = newWidth;
    height = newHeight;

    // Cada pasada bajamos mÃƒÂ¡s la compresiÃƒÂ³n
    compressQuality -= 0.1;
    if (compressQuality < 0.3) {
      compressQuality = 0.3;
    }
  }

  // DespuÃƒÂ©s de los intentos, devolvemos el resultado (aunque quizÃƒÂ¡s siga arriba de 1MB si la imagen era enorme)
  return currentUri;
}

/**
 * El flujo completo de:
 *  1. Elegir la imagen (cÃƒÂ¡mara/galerÃƒÂ­a)
 *  2. Asegurar que quede por debajo de 1MB (ensureUnderMaxSize)
 *  3. Retornar el URI local final de la imagen procesada
 */
export async function pickAndProcessImage(fromCamera: boolean): Promise<string | null> {
  const result = await pickImageFromSource(fromCamera);
  // Verificamos si el usuario cancelÃƒÂ³
  if (!result || result.canceled === true || (result as any).cancelled === true) {
    return null;
  }
  // En SDKs modernos, result.assets es un array con los datos de la imagen
  const asset = result.assets ? result.assets[0] : result;
  if (!asset || !asset.uri) {
    return null;
  }
  // Llamamos a ensureUnderMaxSize para que el archivo no supere 1MB
  const finalUri = await ensureUnderMaxSize(asset.uri, asset.width, asset.height);
  return finalUri;
}

/**
 * Sube la imagen (finalUri) al servidor con multipart/form-data
 * y retorna el file_id devuelto por la API.
 */
export async function uploadImage(localUri: string, token: string): Promise<number | null> {
  try {
    let filename = localUri.split('/').pop() || 'photo.jpg';
    if (!/\.\w+$/.test(filename)) {
      filename = `${filename}.jpg`;
    }
    const match = /\.(\w+)$/.exec(filename);
    // Forzamos 'jpeg' si la extensiÃƒÂ³n es '.jpg'
    const type = match
      ? `image/${match[1].toLowerCase() === 'jpg' ? 'jpeg' : match[1].toLowerCase()}`
      : 'image/jpeg';

    const formData = new FormData();
    formData.append('file', {
      uri: localUri,
      name: filename,
      type,
    } as any);

    const uploadResponse = await fetch(`${BASE_URL}/upload`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
      },
      body: formData,
    });

    if (!uploadResponse.ok) {
      Alert.alert('Error', 'Error al subir archivo');
      return null;
    }

    const data = await uploadResponse.json();
    const fileId = data?.file?.id;
    return fileId || null;
  } catch (error: any) {
    Alert.alert('Error', error.message);
    return null;
  }
}

---

---
Folder: C:\Users\porma\Desktop\sisa.ui\app
File: ProfileScreen.js
Content:
// app/profile.js (o app/profile/index.js)

import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Button,
  Alert,
  TextInput,
  TouchableOpacity,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { BASE_URL } from '../src/config/index';

import CircleImagePicker from '../src/components/CircleImagePicker';

export default function ProfileScreen() {
  const router = useRouter();

  // Datos bÃ¡sicos del usuario
  const [userData, setUserData] = useState({
    user_id: null,
    username: null,
    email: null,
  });

  // Datos de perfil
  const [profileDetails, setProfileDetails] = useState(null);

  // Modo ediciÃ³n
  const [editProfile, setEditProfile] = useState(false);

  // Formulario para editar
  const [profileForm, setProfileForm] = useState({
    full_name: '',
    phone: '',
    address: '',
    cuit: '',
    profile_file_id: '',
  });

  // Cargar datos bÃ¡sicos (user_id, username, email) de AsyncStorage
  useEffect(() => {
    const loadUserData = async () => {
      try {
        const user_id = await AsyncStorage.getItem('user_id');
        const username = await AsyncStorage.getItem('username');
        const email = await AsyncStorage.getItem('email');
        setUserData({ user_id, username, email });
      } catch (error) {
        console.log('Error al cargar datos del usuario:', error);
      }
    };
    loadUserData();
  }, []);

  // Cargar perfil desde la API
  const loadProfile = async () => {
    if (!userData.user_id) return;
    const token = await AsyncStorage.getItem('token');
    if (!token) return;

    try {
      const profileResponse = await fetch(
        `${BASE_URL}/user_profile/${userData.user_id}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      if (profileResponse.ok) {
        const profileData = await profileResponse.json();
        const profile = profileData.profile;
        setProfileDetails(profile);
        // Llenamos el formulario
        setProfileForm({
          full_name: profile.full_name || '',
          phone: profile.phone || '',
          address: profile.address || '',
          cuit: profile.cuit || '',
          profile_file_id: profile.profile_file_id
            ? profile.profile_file_id.toString()
            : '',
        });
      } else {
        console.error('Error al obtener el perfil');
      }
    } catch (error) {
      console.error('Error en fetch de perfil:', error);
    }
  };

  useEffect(() => {
    loadProfile();
  }, [userData.user_id]);

  // Callback al cambiar la imagen (subir nueva foto)
  const handleImageUpdate = async (newFileId) => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const updateResponse = await fetch(`${BASE_URL}/user_profile`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          full_name: profileForm.full_name,
          phone: profileForm.phone,
          address: profileForm.address,
          cuit: profileForm.cuit,
          profile_file_id: newFileId,
        }),
      });
      if (updateResponse.ok) {
        loadProfile(); // Recargamos datos de perfil
      } else {
        const errData = await updateResponse.json();
        Alert.alert('Error', errData.error || 'Error actualizando perfil');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  // Guardar cambios en perfil (PUT)
  const handleProfileSave = async () => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/user_profile`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          full_name: profileForm.full_name,
          phone: profileForm.phone,
          address: profileForm.address,
          cuit: profileForm.cuit,
          profile_file_id:
            profileForm.profile_file_id === ''
              ? null
              : parseInt(profileForm.profile_file_id),
        }),
      });
      if (response.ok) {
        // Actualizamos localmente
        if (profileDetails) {
          setProfileDetails({ ...profileDetails, ...profileForm });
        }
        setEditProfile(false);
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error actualizando perfil');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  // Cerrar sesiÃ³n
  const handleLogout = async () => {
    try {
      await AsyncStorage.removeItem('token');
      await AsyncStorage.removeItem('user_id');
      await AsyncStorage.removeItem('username');
      await AsyncStorage.removeItem('email');
      Alert.alert('SesiÃ³n cerrada');
      router.replace('./login/login');
    } catch (error) {
      console.log('Error al cerrar sesiÃ³n:', error);
    }
  };

  //Elimina la Cuenta
  const handleDeleteAccount = async () => {
    Alert.alert(
      'Eliminar cuenta',
      'Esta acciÃ³n es irreversible. Â¿Deseas continuar?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Eliminar',
          style: 'destructive',
          onPress: async () => {
            const token = await AsyncStorage.getItem('token');
            if (!token) return;
            try {
              const response = await fetch(`${BASE_URL}/users/${userData.user_id}`, {
                method: 'DELETE',
                headers: { Authorization: `Bearer ${token}` },
              });
  
              if (response.ok) {
                await AsyncStorage.clear();
                Alert.alert('Cuenta eliminada');
                router.replace('./login');
              } else {
                Alert.alert('Error', 'No se pudo eliminar la cuenta.');
              }
            } catch (error) {
              Alert.alert('Error', error.message);
            }
          },
        },
      ]
    );
  };
  

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.subtitle}>Perfil</Text>

      {profileDetails ? (
        <View style={styles.dataContainer}>
          {/* Foto en cÃ­rculo editable */}
          <CircleImagePicker
            fileId={profileDetails.profile_file_id}
            editable={true}
            size={200}
            onImageChange={handleImageUpdate}
          />

          <Text style={styles.infoText}>Username: {userData.username}</Text>
          <Text style={styles.infoText}>Email: {userData.email}</Text>

          {editProfile ? (
            <>
              <TextInput
                style={styles.input}
                value={profileForm.full_name}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, full_name: text })
                }
                placeholder="Nombre completo"
              />
              <TextInput
                style={styles.input}
                value={profileForm.phone}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, phone: text })
                }
                placeholder="TelÃ©fono"
                keyboardType="phone-pad"
              />
              <TextInput
                style={styles.input}
                value={profileForm.address}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, address: text })
                }
                placeholder="DirecciÃ³n"
              />
              <TextInput
                style={styles.input}
                value={profileForm.cuit}
                onChangeText={(text) =>
                  setProfileForm({ ...profileForm, cuit: text })
                }
                placeholder="CUIT"
                keyboardType="numeric"
              />

              <Button title="Guardar Perfil" onPress={handleProfileSave} />
            </>
          ) : (
            <>
              <Text style={styles.infoText}>Nombre: {profileDetails.full_name}</Text>
              <Text style={styles.infoText}>TelÃ©fono: {profileDetails.phone}</Text>
              <Text style={styles.infoText}>DirecciÃ³n: {profileDetails.address}</Text>
              <Text style={styles.infoText}>CUIT: {profileDetails.cuit}</Text>

              <TouchableOpacity
                style={styles.editButton}
                onPress={() => setEditProfile(true)}
              >
                <Text style={styles.editButtonText}>Editar Perfil</Text>
              </TouchableOpacity>
            </>
          )}
        </View>
      ) : (
        <Text style={styles.infoText}>Cargando perfil...</Text>
      )}
      <Button title="Eliminar Cuenta" onPress={handleDeleteAccount} color="red" />
      <Button title="Cerrar SesiÃ³n" onPress={handleLogout} />
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  subtitle: {
    fontSize: 22,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  dataContainer: {
    backgroundColor: '#f5f5f5',
    padding: 15,
    borderRadius: 10,
    marginBottom: 20,
    justifyContent: 'center',
  },
  infoText: { fontSize: 18, marginVertical: 5 },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 8,
    borderRadius: 5,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  editButton: {
    backgroundColor: '#007BFF',
    borderRadius: 10,
    padding: 15,
    marginTop: 10,
    alignItems: 'center',
  },
  editButtonText: {
    color: '#fff',
    fontSize: 18,
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app
File: UserProfile.js
Content:
// UserProfile.js
import React, { useContext } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import { UserContext } from './UserContext';

const UserProfile = () => {
  const { user, setUser } = useContext(UserContext);

  // FunciÃ³n para actualizar la informaciÃ³n del usuario
  const updateUser = () => {
    setUser({
      id: 2,
      username: 'jane_doe',
      email: 'jane@example.com',
    });
  };

  return (
    <View style={styles.container}>
      <Text style={styles.label}>Username: {user.username}</Text>
      <Text style={styles.label}>Email: {user.email}</Text>
      <Button title="Update User" onPress={updateUser} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { 
    alignItems: 'center' 
  },
  label: { 
    fontSize: 16, 
    marginBottom: 10 
  },
});

export default UserProfile;

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\clients
File: AddClient.js
Content:
// app/clients/AddClient.js
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  Alert,
  Button,
  ScrollView,
  TouchableOpacity,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { BASE_URL } from '../../src/config/index';

// Importamos el nuevo recurso
import CircleImagePicker from '../../src/components/CircleImagePicker';

export default function AddClient() {
  const router = useRouter();
  const [form, setForm] = useState({
    business_name: '',
    tax_id: '',
    email: '',
    brand_file_id: null,
    phone: '',
    address: '',
  });

  // Callback al actualizar la imagen (nueva fileId)
  const handleImageUpdate = (newFileId) => {
    setForm({ ...form, brand_file_id: newFileId });
  };

  // Crear un nuevo cliente (POST)
  const handleSave = async () => {
    try {
      const token = await AsyncStorage.getItem('token');
      if (!token) return;

      const response = await fetch(`${BASE_URL}/clients`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(form),
      });

      if (response.ok) {
        Alert.alert('Ã‰xito', 'Cliente creado');
        router.push('./ClientsScreen');
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error al guardar');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>Agregar Cliente</Text>

      <CircleImagePicker
        fileId={form.brand_file_id}
        onImageChange={handleImageUpdate}
        editable={true}
        size={200}
      />

      <TextInput
        style={styles.input}
        placeholder="RazÃ³n Social"
        value={form.business_name}
        onChangeText={(text) => setForm({ ...form, business_name: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="CUIT / Tax ID"
        value={form.tax_id}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, tax_id: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={form.email}
        keyboardType="email-address"
        onChangeText={(text) => setForm({ ...form, email: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="TelÃ©fono"
        value={form.phone}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, phone: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="DirecciÃ³n"
        value={form.address}
        onChangeText={(text) => setForm({ ...form, address: text })}
      />

      <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
        <Text style={styles.saveButtonText}>Crear</Text>
      </TouchableOpacity>

      <Button title="Cancelar" onPress={() => router.push('./ClientsScreen')} />
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, backgroundColor: '#fff' },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20, textAlign: 'center' },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 5,
    borderRadius: 5,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  saveButton: {
    backgroundColor: '#007BFF',
    padding: 15,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\clients
File: ClientItem.js
Content:
// app/clients/ClientItem.js
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Alert } from 'react-native';
import CircleImagePicker from '../../src/components/CircleImagePicker';

/**
 * item: datos del cliente
 * expanded: bool para controlar expandido
 * onToggle, onDelete, onEdit: callbacks
 */
export default function ClientItem({ item, expanded, onToggle, onDelete, onEdit }) {

  const handleToggle = () => {
    onToggle(item.id);
  };

  // Ajusta un tamaÃ±o mÃ¡s chico, por ejemplo 50
  const avatarSize = expanded ? 80 : 50;

  return (
    <TouchableOpacity onPress={handleToggle} activeOpacity={0.8}>
      <View style={styles.itemContainer}>
        <View style={styles.headerRow}>
          <Text style={styles.companyName}>{item.business_name}</Text>

          {/* Usa CircleImagePicker en modo lectura (editable={false}). 
              Carga la imagen a partir de brand_file_id */}
          <CircleImagePicker
            fileId={item.brand_file_id}
            editable={false}
            size={avatarSize}
          />
        </View>

        {expanded && (
          <>
            <Text style={styles.itemText}>CUIT: {item.tax_id}</Text>
            <Text style={styles.itemText}>Email: {item.email}</Text>
            <Text style={styles.itemText}>DirecciÃ³n: {item.address}</Text>
            <Text style={styles.itemText}>TelÃ©fono: {item.phone}</Text>

            <View style={styles.buttonContainer}>
              <TouchableOpacity style={styles.button} onPress={() => onEdit(item.id)}>
                <Text style={styles.buttonText}>Editar</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, styles.deleteButton]}
                onPress={() =>
                  Alert.alert(
                    'Confirmar',
                    'Â¿EstÃ¡s seguro de eliminar este cliente?',
                    [
                      { text: 'Cancelar', style: 'cancel' },
                      {
                        text: 'Eliminar',
                        style: 'destructive',
                        onPress: () => onDelete(item.id),
                      },
                    ]
                  )
                }
              >
                <Text style={styles.buttonText}>Eliminar</Text>
              </TouchableOpacity>
            </View>
          </>
        )}
      </View>
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  itemContainer: {
    width: '100%',
    backgroundColor: '#E2E2FA',
    borderRadius: 10,
    padding: 15,
    marginBottom: 15,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  companyName: {
    fontSize: 18,
    fontWeight: 'bold',
    flexShrink: 1,
  },
  itemText: {
    fontSize: 16,
    marginTop: 5,
  },
  buttonContainer: {
    width: '100%',
    flexDirection: 'row',
    marginTop: 10,
  },
  button: {
    flex: 1,
    backgroundColor: '#007BFF',
    padding: 15,
    borderRadius: 5,
    marginRight: 10,
    alignItems: 'center',
  },
  deleteButton: {
    backgroundColor: '#FF3333',
    marginRight: 0,
  },
  buttonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\clients
File: clientList.js
Content:
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  Alert,
  ActivityIndicator,
  Platform,
  UIManager,
  LayoutAnimation,
  TextInput,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import ClientItem from './ClientItem';
import { BASE_URL } from '../../src/config/index';
import Fuse from 'fuse.js';

export default function ClientList({ onSelectedClient }) {
  const router = useRouter();
  const [clients, setClients] = useState([]);
  const [filteredClients, setFilteredClients] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  // Estado para almacenar el id del item actualmente expandido (null si ninguno)
  const [expandedItemId, setExpandedItemId] = useState(null);

// Propagar el cliente seleccionado al componente contenedor
useEffect(() => {
  if (onSelectedClient) {
    const selectedClient = clients.find(client => client.id === expandedItemId);
    onSelectedClient(selectedClient || null);
  }
}, [expandedItemId, clients]);

  // Activar animaciones en Android
  useEffect(() => {
    if (Platform.OS === 'android') {
      UIManager.setLayoutAnimationEnabledExperimental &&
        UIManager.setLayoutAnimationEnabledExperimental(true);
    }
  }, []);

  // Cargar clientes desde la API
  const loadClients = async () => {
    setLoading(true);
    const token = await AsyncStorage.getItem('token');
    if (!token) {
      setLoading(false);
      return;
    }
    try {
      const response = await fetch(`${BASE_URL}/clients`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const data = await response.json();
        const allClients = data.clients || data;
        setClients(allClients);
        setFilteredClients(allClients);
      } else {
        Alert.alert('Error', 'No se pudieron obtener los clientes');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadClients();
  }, []);

  // Configurar Fuse para bÃºsqueda avanzada (fuzzy search)
  useEffect(() => {
    if (searchQuery.trim() === '') {
      setFilteredClients(clients);
      return;
    }
    const options = {
      keys: ['business_name', 'tax_id', 'email', 'address', 'phone'],
      threshold: 0.4, // Ajusta la sensibilidad de la bÃºsqueda
      includeScore: true,
    };
    const fuse = new Fuse(clients, options);
    const results = fuse.search(searchQuery);
    const matchedClients = results.map(result => result.item);
    setFilteredClients(matchedClients);
  }, [searchQuery, clients]);

  const handleDelete = async (clientId) => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;
    try {
      const response = await fetch(`${BASE_URL}/clients/${clientId}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        Alert.alert('Cliente eliminado');
        loadClients();
        if (expandedItemId === clientId) {
          setExpandedItemId(null);
        }
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error eliminando el cliente');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  const handleEdit = (clientId) => {
    router.push(`./editClient?id=${clientId}`);
  };

  // Alterna el estado expandido: solo un item se expande a la vez
  const handleToggle = (clientId) => {
    if (Platform.OS !== 'web' && LayoutAnimation && LayoutAnimation.configureNext) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    }
    setExpandedItemId(prev => (prev === clientId ? null : clientId));
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.searchInput}
        placeholder="Buscar clientes..."
        value={searchQuery}
        onChangeText={setSearchQuery}
      />
      {loading ? (
        <ActivityIndicator size="large" color="#007BFF" style={styles.loader} />
      ) : (
        <FlatList
          data={filteredClients}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <ClientItem
              item={item}
              expanded={expandedItemId === item.id}
              onToggle={handleToggle}
              onDelete={handleDelete}
              onEdit={handleEdit}
            />
          )}
          contentContainerStyle={styles.listContainer}
          ListEmptyComponent={<Text>No hay clientes disponibles.</Text>}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    width: '100%',  // Se ocupa todo el ancho de la pantalla
    backgroundColor: '#fff',
  },
  searchInput: {
    height: 40,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    paddingHorizontal: 10,
  },
  listContainer: { 
    marginTop: 20,
  },
  loader: { 
    marginTop: 20,
  },
  selectedClientText: {
    fontSize: 16,
    fontWeight: 'bold',
    marginVertical: 10,
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\clients
File: ClientsScreen.js
Content:
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import ClientList from './clientList';
import { useRouter } from 'expo-router';

export default function ClientsScreen() {
  const [selectedClient, setSelectedClient] = useState(null);
  const router = useRouter();

  //console.log(selectedClient.id);

  const handleAddClient = () => {
    router.push('./AddClient');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Lista de Clientes</Text>
      <ClientList onSelectedClient={setSelectedClient} />
      <TouchableOpacity style={styles.floatingButton} onPress={handleAddClient}>
        <Text style={styles.floatingButtonText}>+</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#fff',
    padding: 20 
  },
  title: { 
    fontSize: 24, 
    fontWeight: 'bold', 
    marginBottom: 10,
    textAlign: 'center',
  },
  floatingButton: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    backgroundColor: '#007BFF',
    width: 60,
    height: 60,
    borderRadius: 30,
    alignItems: 'center',
    justifyContent: 'center',
    // Sombra para Android e iOS
    elevation: 5,
    shadowColor: '#000',
    shadowOpacity: 0.3,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 2,
  },
  floatingButtonText: {
    fontSize: 30,
    color: '#fff',
    marginTop: -4, // Ajuste fino para centrar el '+'
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\clients
File: editClient.js
Content:
// app/clients/editClient.js
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  Alert,
  ActivityIndicator,
  Button,
  ScrollView,
  TouchableOpacity,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { useRoute } from '@react-navigation/native';
import { BASE_URL } from '../../src/config/index';

// Importamos el CircleImagePicker
import CircleImagePicker from '../../src/components/CircleImagePicker';

export default function EditClient() {
  const router = useRouter();
  const route = useRoute();
  const { id } = route.params; // id del cliente

  const [loading, setLoading] = useState(false);
  const [form, setForm] = useState({
    business_name: '',
    tax_id: '',
    email: '',
    brand_file_id: null,
    phone: '',
    address: '',
  });

  // Cargar datos del cliente en modo ediciÃ³n
  const loadClient = async () => {
    if (!id) return;
    setLoading(true);
    try {
      const token = await AsyncStorage.getItem('token');
      if (!token) return;

      const response = await fetch(`${BASE_URL}/clients/${id}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const data = await response.json();
        const client = data.client;
        setForm({
          business_name: client.business_name || '',
          tax_id: client.tax_id || '',
          email: client.email || '',
          brand_file_id: client.brand_file_id,
          phone: client.phone || '',
          address: client.address || '',
        });
      } else {
        Alert.alert('Error', 'No se pudo obtener la informaciÃ³n del cliente');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (id) {
      loadClient();
    }
  }, [id]);

  // Callback cuando se suba una nueva imagen
  const handleImageUpdate = (newFileId) => {
    // Actualizamos el brand_file_id en nuestro formulario
    setForm({ ...form, brand_file_id: newFileId });
  };

  // Guardar cambios
  const handleSave = async () => {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;

    const url = id ? `${BASE_URL}/clients/${id}` : `${BASE_URL}/clients`;
    const method = id ? 'PUT' : 'POST';

    try {
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(form),
      });
      if (response.ok) {
        Alert.alert('Ã‰xito', id ? 'Cliente actualizado' : 'Cliente creado');
        router.push('./ClientsScreen');
      } else {
        const errData = await response.json();
        Alert.alert('Error', errData.error || 'Error al guardar');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  // Eliminar cliente
  const handleDelete = async () => {
    if (!id) return;
    Alert.alert(
      'Confirmar',
      'Â¿EstÃ¡s seguro de eliminar este cliente?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Eliminar',
          style: 'destructive',
          onPress: async () => {
            try {
              const token = await AsyncStorage.getItem('token');
              if (!token) return;
              const response = await fetch(`${BASE_URL}/clients/${id}`, {
                method: 'DELETE',
                headers: { Authorization: `Bearer ${token}` },
              });
              if (response.ok) {
                Alert.alert('Ã‰xito', 'Cliente eliminado');
                router.push('./ClientsScreen');
              } else {
                const errData = await response.json();
                Alert.alert('Error', errData.error || 'Error eliminando el cliente');
              }
            } catch (error) {
              Alert.alert('Error', error.message);
            }
          },
        },
      ]
    );
  };

  if (loading) {
    return (
      <View style={styles.loaderContainer}>
        <ActivityIndicator size="large" color="#007BFF" />
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>{id ? 'Editar Cliente' : 'Agregar Cliente'}</Text>

      {/* USO de CircleImagePicker con tamaÃ±o 120 y editable */}
      <CircleImagePicker
        fileId={form.brand_file_id}
        size={200}
        editable={true}
        onImageChange={handleImageUpdate}
      />

      <TextInput
        style={styles.input}
        placeholder="RazÃ³n Social"
        value={form.business_name}
        onChangeText={(text) => setForm({ ...form, business_name: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="CUIT / Tax ID"
        value={form.tax_id}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, tax_id: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={form.email}
        keyboardType="email-address"
        onChangeText={(text) => setForm({ ...form, email: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="TelÃ©fono"
        value={form.phone}
        keyboardType="numeric"
        onChangeText={(text) => setForm({ ...form, phone: text })}
      />
      <TextInput
        style={styles.input}
        placeholder="DirecciÃ³n"
        value={form.address}
        onChangeText={(text) => setForm({ ...form, address: text })}
      />

      <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
        <Text style={styles.saveButtonText}>{id ? 'Actualizar' : 'Crear'}</Text>
      </TouchableOpacity>
      {id && (
        <TouchableOpacity style={styles.deleteButton} onPress={handleDelete}>
          <Text style={styles.deleteButtonText}>Eliminar Cliente</Text>
        </TouchableOpacity>
      )}
      <Button title="Cancelar" onPress={() => router.push('./ClientsScreen')} />
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, backgroundColor: '#fff' },
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20, textAlign: 'center' },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 5,
    borderRadius: 5,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  saveButton: {
    backgroundColor: '#007BFF',
    padding: 15,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  deleteButton: {
    backgroundColor: '#FF3333',
    padding: 15,
    borderRadius: 10,
    marginBottom: 10,
    alignItems: 'center',
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\login
File: forgot-password.js
Content:
import React, { useState } from 'react';
import { View, TextInput, Button, Alert, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from '../../src/config/index';

export default function ForgotPassword() {
  const router = useRouter();
  const [email, setEmail] = useState('');

  const handleForgotPassword = async () => {
    if (!email) {
      Alert.alert('Error', 'Por favor ingresa tu email');
      return;
    }
    try {
      // USAMOS BASE_URL
      const response = await fetch(`${BASE_URL}/forgot_password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
      });
      const result = await response.json();
      if (response.ok) {
        Alert.alert('Ã‰xito', result.message || 'Email de recuperaciÃ³n enviado');
        router.replace('./login');
      } else {
        Alert.alert('Error', result.error || 'Error al enviar la solicitud');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Ingresa tu email"
        style={styles.input}
        value={email}
        keyboardType="email-address"
        onChangeText={setEmail}
      />
      <Button title="Enviar recuperaciÃ³n" onPress={handleForgotPassword} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  input: { borderWidth: 1, padding: 10, marginBottom: 10 },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\login
File: login.js
Content:
import React, { useState } from 'react';
import { View, TextInput, Button, Alert, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from '../../src/config/index';

export default function Login() {
  const router = useRouter();
  const [username, setUsername] = useState('pormauro');
  const [password, setPassword] = useState('123456');

  const handleLogin = async () => {
    if (!username || !password) {
      Alert.alert('Error', 'Ingresa username y contraseÃ±a');
      return;
    }
    try {
      // USAMOS BASE_URL
      const response = await fetch(`${BASE_URL}/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      });

      if (response.ok) {
        const authHeader = response.headers.get('Authorization');
        const token = authHeader && authHeader.startsWith('Bearer ')
          ? authHeader.split(' ')[1]
          : null;

        if (token) {
          // Guardamos el token en AsyncStorage
          await AsyncStorage.setItem('token', token);

          // Solicitar el perfil del usuario para guardar sus datos
          const profileResponse = await fetch(`${BASE_URL}/profile`, {
            method: 'GET',
            headers: { 
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
          });

          if (profileResponse.ok) {
            const profileData = await profileResponse.json();
            const { id, username: userName, email } = profileData.user;
            await AsyncStorage.setItem('user_id', id.toString());
            await AsyncStorage.setItem('username', userName);
            await AsyncStorage.setItem('email', email);

            // Redirigir a Home
            router.replace('../home');
          } else {
            Alert.alert('Error', 'No se pudo obtener el perfil del usuario');
          }
        } else {
          Alert.alert('Error', 'Token no recibido en el encabezado');
        }
      } else {
        const result = await response.json();
        Alert.alert('Error', result.error || 'Credenciales invÃ¡lidas');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Username"
        style={styles.input}
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        placeholder="ContraseÃ±a"
        secureTextEntry
        style={styles.input}
        value={password}
        onChangeText={setPassword}
      />
      <Button title="Ingresar" onPress={handleLogin} />
      <Button title="Registrarse" onPress={() => router.push('./register')} />
      <Button title="OlvidÃ© mi contraseÃ±a" onPress={() => router.push('./forgot-password')} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, justifyContent: 'center' },
  input: { borderWidth: 1, padding: 10, marginBottom: 10 },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\app\login
File: register.js
Content:
import React, { useState } from 'react';
import { View, TextInput, Button, Alert, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
// <-- IMPORTAMOS BASE_URL
import { BASE_URL } from '../../src/config/index';

export default function Register () {
  const router = useRouter();
  const [username, setUsername] = useState('pormauro');
  const [email, setEmail] = useState('pormauro@gmail.com');
  const [password, setPassword] = useState('123456');

  const isValidPassword = (password) => {
    return /^(?=.*[A-Z])(?=.*\d).{8,}$/.test(password);
  };
  const handleRegister = async () => {
    if (!isValidPassword(password)) {
      Alert.alert('Error', 'La contraseÃ±a debe tener al menos 8 caracteres, una mayÃºscula y un nÃºmero.');
      return;
    }
    
    if (!username || !email || !password) {
      Alert.alert('Error', 'Todos los campos son requeridos');
      return;
    }
    try {
      // USAMOS BASE_URL
      const response = await fetch(`${BASE_URL}/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, email, password }),
      });
      const result = await response.json();
      if (response.ok) {
        Alert.alert(
          'Ã‰xito',
          result.message || 'Usuario registrado. Revisa tu email para activar la cuenta.'
        );
        router.replace('./login');
      } else {
        Alert.alert('Error', result.error || 'Error en el registro');
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Nombre de usuario"
        style={styles.input}
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        placeholder="Correo electrÃ³nico"
        style={styles.input}
        value={email}
        keyboardType="email-address"
        onChangeText={setEmail}
      />
      <TextInput
        placeholder="ContraseÃ±a"
        secureTextEntry
        style={styles.input}
        value={password}
        onChangeText={setPassword}
      />
      <Button title="Registrar" onPress={handleRegister} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20 },
  input: { borderWidth: 1, padding: 10, marginBottom: 10 },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\src\components
File: CameraImagePicker.ts
Content:
// sisa/app/utils/imageUtils.ts

import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import * as FileSystem from 'expo-file-system';
import { Alert } from 'react-native';
import { BASE_URL, MAX_FILE_SIZE } from '../config/index';

/**
 * Solicita permisos para cÃ¡mara o galerÃ­a, abre la fuente de imagen
 * y retorna el objeto resultante de ImagePicker.
 * Se han agregado opciones para optimizar el uso de memoria y evitar reinicios.
 */
export async function pickImageFromSource(fromCamera: boolean) {
  try {
    if (fromCamera) {
      const { status } = await ImagePicker.requestCameraPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permiso denegado', 'Se requieren permisos de cÃ¡mara.');
        return null;
      }
      return await ImagePicker.launchCameraAsync({
        quality: 0.7,
        allowsEditing: false,
        exif: false,
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
      });
    } else {
      const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permiso denegado', 'Se requieren permisos de galerÃ­a.');
        return null;
      }
      return await ImagePicker.launchImageLibraryAsync({
        quality: 0.7,
        allowsEditing: false,
        exif: false,
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
      });
    }
  } catch (error: any) {
    Alert.alert('Error', error.message);
    return null;
  }
}

/**
 * Verifica y comprime/redimensiona la imagen hasta que su tamaÃ±o sea <= MAX_FILE_SIZE (1MB).
 * Realiza hasta 3 intentos reduciendo gradualmente el tamaÃ±o y la compresiÃ³n.
 * Retorna el URI final de la imagen procesada.
 */
async function ensureUnderMaxSize(
  uri: string,
  originalWidth: number,
  originalHeight: number
): Promise<string> {
  let currentUri = uri;
  let width = originalWidth;
  let height = originalHeight;

  const maxPasses = 3;
  let compressQuality = 0.7;

  for (let attempt = 1; attempt <= maxPasses; attempt++) {
    const fileInfo = await FileSystem.getInfoAsync(currentUri);
    if (!fileInfo.exists || typeof fileInfo.size !== 'number') {
      return currentUri;
    }
    if (fileInfo.size <= MAX_FILE_SIZE) {
      return currentUri;
    }
    // Calcula el ratio para acercarse al lÃ­mite
    const ratio = Math.sqrt(MAX_FILE_SIZE / fileInfo.size);
    const newWidth = Math.floor(width * Math.min(ratio, 0.9));
    const newHeight = Math.floor(height * Math.min(ratio, 0.9));

    const manipResult = await ImageManipulator.manipulateAsync(
      currentUri,
      [{ resize: { width: newWidth, height: newHeight } }],
      {
        compress: compressQuality,
        format: ImageManipulator.SaveFormat.JPEG,
      }
    );

    currentUri = manipResult.uri;
    width = newWidth;
    height = newHeight;
    compressQuality = Math.max(compressQuality - 0.1, 0.3);
  }

  return currentUri;
}

/**
 * Flujo completo para:
 * 1. Elegir la imagen (cÃ¡mara/galerÃ­a)
 * 2. Asegurar que la imagen procesada estÃ© por debajo de 1MB
 * 3. Retornar el URI final de la imagen
 */
export async function pickAndProcessImage(fromCamera: boolean): Promise<string | null> {
  try {
    const result = await pickImageFromSource(fromCamera);
    // Verifica si el usuario cancelÃ³ la acciÃ³n
    if (!result || result.canceled === true || (result as any).cancelled === true) {
      return null;
    }
    // En versiones modernas, el resultado contiene un array en result.assets
    const asset = result.assets ? result.assets[0] : result;
    if (!asset || !asset.uri) {
      return null;
    }
    const finalUri = await ensureUnderMaxSize(asset.uri, asset.width, asset.height);
    return finalUri;
  } catch (error: any) {
    Alert.alert('Error al seleccionar imagen', error.message);
    return null;
  }
}

/**
 * Sube la imagen (finalUri) al servidor usando multipart/form-data y retorna el file_id devuelto.
 */
export async function uploadImage(localUri: string, token: string): Promise<number | null> {
  try {
    let filename = localUri.split('/').pop() || 'photo.jpg';
    if (!/\.\w+$/.test(filename)) {
      filename = `${filename}.jpg`;
    }
    const match = /\.(\w+)$/.exec(filename);
    const type = match
      ? `image/${match[1].toLowerCase() === 'jpg' ? 'jpeg' : match[1].toLowerCase()}`
      : 'image/jpeg';

    const formData = new FormData();
    formData.append('file', {
      uri: localUri,
      name: filename,
      type,
    } as any);

    const uploadResponse = await fetch(`${BASE_URL}/upload`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
      },
      body: formData,
    });

    if (!uploadResponse.ok) {
      Alert.alert('Error', 'Error al subir archivo');
      return null;
    }

    const data = await uploadResponse.json();
    const fileId = data?.file?.id;
    return fileId || null;
  } catch (error: any) {
    Alert.alert('Error', error.message);
    return null;
  }
}

---
Folder: C:\Users\porma\Desktop\sisa.ui\src\components
File: CircleImagePicker.js
Content:
// app/components/CircleImagePicker.js
import React, { useState, useEffect } from 'react';
import { 
  View,
  TouchableOpacity,
  StyleSheet,
  Alert,
  Image,
  ActivityIndicator,
  Text
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { pickAndProcessImage, uploadImage } from '../utils/imageUtils';
import { BASE_URL } from '../config/index';

/**
 * Componente para mostrar la imagen en un cÃ­rculo. Puede ser:
 * - SÃ³lo lectura (editable={false}), sin botÃ³n de cÃ¡mara.
 * - Editable (editable={true}), con botÃ³n de cÃ¡mara para cambiar la imagen.
 * 
 * Props:
 *  - fileId    : (opcional) ID de archivo en el servidor. Se descargarÃ¡ la imagen de /get_file?file_id=xxx
 *  - imageUri  : (opcional) URI local (o remota) a usar directamente.
 *  - editable  : boolean que indica si se muestra el icono de cÃ¡mara.
 *  - onImageChange(newFileId) : callback cuando se sube con Ã©xito una imagen y se obtiene un nuevo fileId.
 *  - size      : tamaÃ±o del cÃ­rculo (ancho/alto).
 */
export default function CircleImagePicker({
  fileId = null,
  imageUri = null,
  editable = false,
  size = 80,
  onImageChange,
  style,
}) {
  const [loading, setLoading] = useState(false);
  const [internalUri, setInternalUri] = useState(null);
  const [hasError, setHasError] = useState(false);

  useEffect(() => {
    if (imageUri) {
      // Usar directamente la URI pasada
      setInternalUri(imageUri);
      setHasError(false);
    } else if (fileId) {
      // Cargar la imagen desde el servidor
      loadFileFromServer(fileId);
    } else {
      // No hay imagen
      setInternalUri(null);
      setHasError(false);
    }
  }, [fileId, imageUri]);

  const loadFileFromServer = async (fId) => {
    try {
      setLoading(true);
      setHasError(false);
      const token = await AsyncStorage.getItem('token');
      if (!token) {
        setHasError(true);
        setLoading(false);
        return;
      }
      const response = await fetch(`${BASE_URL}/get_file?file_id=${fId}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (response.ok) {
        const blob = await response.blob();
        const reader = new FileReader();
        reader.onloadend = () => {
          setInternalUri(reader.result);
          setLoading(false);
        };
        reader.readAsDataURL(blob);
      } else {
        setHasError(true);
        setLoading(false);
      }
    } catch (error) {
      setHasError(true);
      setLoading(false);
    }
  };

  // Abre cÃ¡mara o galerÃ­a, sube la imagen
  const handleSelectImage = () => {
    Alert.alert(
      'Seleccionar Imagen',
      'Â¿Deseas usar la cÃ¡mara o la galerÃ­a?',
      [
        { text: 'CÃ¡mara', onPress: () => pickAndUpload(true) },
        { text: 'GalerÃ­a', onPress: () => pickAndUpload(false) },
        { text: 'Cancelar', style: 'cancel' },
      ],
      { cancelable: true }
    );
  };

  const pickAndUpload = async (fromCamera) => {
    try {
      setLoading(true);
      const newUri = await pickAndProcessImage(fromCamera);
      if (!newUri) {
        // Usuario cancelÃ³
        setLoading(false);
        return;
      }
      const token = await AsyncStorage.getItem('token');
      if (!token) {
        Alert.alert('Error', 'No se encontrÃ³ token');
        setLoading(false);
        return;
      }

      // Subir la imagen
      const newFileId = await uploadImage(newUri, token);
      if (newFileId) {
        setInternalUri(newUri);
        setHasError(false);
        if (onImageChange) {
          onImageChange(newFileId);
        }
      } else {
        Alert.alert('Error', 'No se pudo subir la imagen');
      }
    } catch (err) {
      Alert.alert('Error', err.message);
    } finally {
      setLoading(false);
    }
  };

  // Aplicar el tamaÃ±o (width/height) dinÃ¡micamente
  const circleStyle = {
    width: size,
    height: size,
    borderRadius: size / 2,
  };

  return (
    <View style={[styles.container, style, circleStyle]}>
      {loading && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator color="#fff" size="large" />
        </View>
      )}

      {/* Mostrar la imagen si tenemos URI, o un placeholder azul */}
      {internalUri && !hasError ? (
        <Image
          source={{ uri: internalUri }}
          style={[styles.image, { width: size, height: size, borderRadius: size / 2 }, loading && { opacity: 0.4 }]}
        />
      ) : (
        <View style={[styles.image, styles.placeholder, circleStyle]} />
      )}

      {/* BotÃ³n de cÃ¡mara si es editable */}
      {editable && !loading && (
        <TouchableOpacity style={styles.cameraButton} onPress={handleSelectImage}>
          <Text style={styles.cameraIcon}>ðŸ“·</Text>
        </TouchableOpacity>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignSelf: 'center',
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingOverlay: {
    position: 'absolute',
    zIndex: 2,
  },
  image: {
    resizeMode: 'cover',
  },
  placeholder: {
    backgroundColor: 'blue',
  },
  cameraButton: {
    position: 'absolute',
    right: 0,
    bottom: 0,
    width: '30%',
    height: '30%',
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: '50%',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 3,
  },
  cameraIcon: {
    color: '#fff',
    fontSize: 32,
  },
});

---
Folder: C:\Users\porma\Desktop\sisa.ui\src\components
File: ImageDisplay.js
Content:
// ImageDisplay.js
import React from 'react';
import { View, Image, StyleSheet } from 'react-native';

const ImageDisplay = ({ imageUri, style }) => {
  if (imageUri) {
    return <Image source={{ uri: imageUri }} style={[styles.image, style]} />;
  }
  return <View style={[styles.image, styles.placeholder, style]} />;
};

const styles = StyleSheet.create({
  image: {
    width: 200,
    height: 200,
    borderRadius: 100,
    resizeMode: 'cover',
  },
  placeholder: {
    backgroundColor: 'blue',
  },
});

export default ImageDisplay;

---
Folder: C:\Users\porma\Desktop\sisa.ui\src\config
File: index.js
Content:
export const BASE_URL = 'https://sistema.depros.com.ar';
export const MAX_FILE_SIZE = 1 * 1024 * 1024; // 1 MB
---
Folder: C:\Users\porma\Desktop\sisa.ui\src\contexts
File: AppContext.js
Content:
// AppContext.js
import React, { createContext } from 'react';
import { BASE_URL } from '../config/index';

export const AppContext = createContext({
  baseUrl: BASE_URL,
});

export const AppProvider = ({ children }) => {
  const contextValue = { baseUrl: BASE_URL };

  return (
    <AppContext.Provider value={contextValue}>
      {children}
    </AppContext.Provider>
  );
};

---
Folder: C:\Users\porma\Desktop\sisa.ui\src\contexts
File: UserContext.js
Content:
// UserContext.js
import React, { createContext, useState } from 'react';

// Creamos el contexto con un valor inicial null
export const UserContext = createContext(null);

// Creamos el proveedor para envolver la aplicaciÃ³n
export const UserProvider = ({ children }) => {
  const [user, setUser] = useState({
    id: 1,
    username: 'john_doe',
    email: 'john@example.com',
  });

  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
};

---
Folder: C:\Users\porma\Desktop\sisa.ui\src\database
File: clientsLocalDB.js
Content:
// sisa/app/database/clientsLocalDB.js

import * as SQLite from 'expo-sqlite';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { BASE_URL } from '../config/index';

// Abre (o crea) la base de datos local "mydatabase.db"
const db = SQLite.openDatabase('mydatabase.db');

/**
 * Crea la tabla local "clients" si no existe.
 * Ajusta columnas segÃºn tus necesidades.
 */
export function createLocalClientsTable() {
  db.transaction((tx) => {
    tx.executeSql(
      `CREATE TABLE IF NOT EXISTS clients (
        id INTEGER PRIMARY KEY NOT NULL,
        business_name TEXT NOT NULL,
        tax_id TEXT,
        email TEXT,
        brand_file_id INTEGER,
        phone TEXT,
        address TEXT
        -- PodrÃ­as aÃ±adir user_id, is_deleted, etc.
      );`
    );
  });
}

/**
 * Retorna la lista de todos los clientes en BD local.
 */
export function getAllClientsLocal() {
  return new Promise((resolve, reject) => {
    db.transaction((tx) => {
      tx.executeSql(
        'SELECT * FROM clients',
        [],
        (_, { rows }) => resolve(rows._array),
        (_, error) => reject(error)
      );
    });
  });
}

/**
 * Inserta un cliente en la BD local.
 * Retorna el ID insertado (autoincrement).
 */
export function insertClientLocal(clientData) {
  const {
    business_name,
    tax_id,
    email,
    brand_file_id,
    phone,
    address,
  } = clientData;

  return new Promise((resolve, reject) => {
    db.transaction((tx) => {
      tx.executeSql(
        `INSERT INTO clients (business_name, tax_id, email, brand_file_id, phone, address)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [business_name, tax_id, email, brand_file_id, phone, address],
        (_, result) => {
          // result.insertId es el ID autoincrement
          resolve(result.insertId);
        },
        (_, error) => reject(error)
      );
    });
  });
}

/**
 * Actualiza un cliente local por su id.
 */
export function updateClientLocal(clientId, clientData) {
  const {
    business_name,
    tax_id,
    email,
    brand_file_id,
    phone,
    address,
  } = clientData;

  return new Promise((resolve, reject) => {
    db.transaction((tx) => {
      tx.executeSql(
        `UPDATE clients
         SET business_name = ?, tax_id = ?, email = ?, brand_file_id = ?, phone = ?, address = ?
         WHERE id = ?`,
        [business_name, tax_id, email, brand_file_id, phone, address, clientId],
        (_, result) => resolve(result.rowsAffected),
        (_, error) => reject(error)
      );
    });
  });
}

/**
 * Elimina un cliente local por su id.
 */
export function deleteClientLocal(clientId) {
  return new Promise((resolve, reject) => {
    db.transaction((tx) => {
      tx.executeSql(
        'DELETE FROM clients WHERE id = ?',
        [clientId],
        (_, result) => resolve(result.rowsAffected),
        (_, error) => reject(error)
      );
    });
  });
}

/**
 * Limpia por completo la tabla local.
 */
function clearLocalClients() {
  return new Promise((resolve, reject) => {
    db.transaction((tx) => {
      tx.executeSql(
        'DELETE FROM clients',
        [],
        () => resolve(true),
        (_, err) => reject(err)
      );
    });
  });
}

/* =======================================================
   FUNCIONES DE SINCRONIZACIÃ“N CON EL SERVIDOR
   AquÃ­ reusamos la lÃ³gica que antes tenÃ­as en tus fetch
   (GET /clients, POST/clients, etc.)
========================================================= */

/**
 * "Pull": Descarga la lista del servidor y pisamos la BD local.
 */
export async function syncFromServer() {
  try {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;

    const response = await fetch(`${BASE_URL}/clients`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    if (!response.ok) {
      console.log('syncFromServer: Error al obtener /clients', response.status);
      return;
    }
    const data = await response.json();
    const serverClients = data.clients || [];

    // Borramos lo local y volvemos a insertar todo
    await clearLocalClients();
    createLocalClientsTable();

    for (let c of serverClients) {
      // Reusa la misma funciÃ³n local
      await insertClientLocal({
        business_name: c.business_name,
        tax_id: c.tax_id,
        email: c.email,
        brand_file_id: c.brand_file_id,
        phone: c.phone,
        address: c.address,
        // id se autogenera local; si deseas forzar usar el id del server,
        // podrÃ­as ajustarlo, pero puede causar conflicto si es PK autoinc.
      });
    }

  } catch (error) {
    console.error('syncFromServer: ', error);
  }
}

/**
 * "Push": Subir los cambios locales al servidor.
 * (La forma ideal es con un campo "sync_status" o "updated_at" para no subir todo).
 * AquÃ­ es un ejemplo simple que llama PUT /clients/{id} si ya existe en el server,
 * o POST /clients si es nuevo, etc.
 */
export async function syncToServer() {
  try {
    const token = await AsyncStorage.getItem('token');
    if (!token) return;

    // Obtenemos toda la tabla local
    const localClients = await getAllClientsLocal();

    // Ejemplo super-simplificado:
    // Si en el servidor no existe un "id", se hace POST
    // Caso contrario, se hace PUT. (HabrÃ­a que verificar).
    for (let client of localClients) {
      // Supongamos que "id" local coincide con "id" server,
      // y si no existe, se hace POST. 
      // NOTA: Esto puede fallar en escenarios reales, lo ideal es un "server_id".
      const checkResp = await fetch(`${BASE_URL}/clients/${client.id}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (checkResp.ok) {
        // => existe => PUT
        await fetch(`${BASE_URL}/clients/${client.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(client),
        });
      } else {
        // => no existe => POST
        // (excluyendo id local, pues el server genera su propio id)
        const payload = { ...client };
        delete payload.id;

        await fetch(`${BASE_URL}/clients`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(payload),
        });
      }
    }
  } catch (error) {
    console.error('syncToServer:', error);
  }
}

---
Folder: C:\Users\porma\Desktop\sisa.ui\src\utils
File: imageUtils.ts
Content:
// sisa/app/utils/imageUtils.ts

import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';
import * as FileSystem from 'expo-file-system';
import { Alert } from 'react-native';
import { BASE_URL, MAX_FILE_SIZE } from '../config/index';

/**
 * Solicita permisos para cÃ¡mara o galerÃ­a, abre la fuente de imagen
 * y retorna el objeto resultante de ImagePicker.
 * 
 * NOTA: Se omiten 'allowsEditing' y 'aspect' para evitar reinicios/crashes en algunos Android.
 *       Se reduce la calidad a 0.7 (70%) para no generar archivos muy grandes de inicio.
 */
export async function pickImageFromSource(fromCamera: boolean) {
  if (fromCamera) {
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Permiso denegado', 'Se requieren permisos de cÃ¡mara.');
      return null;
    }
    return await ImagePicker.launchCameraAsync({
      quality: 0.7,
    });
  } else {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Permiso denegado', 'Se requieren permisos de galerÃ­a.');
      return null;
    }
    return await ImagePicker.launchImageLibraryAsync({
      quality: 0.7,
    });
  }
}

/**
 * Verifica y comprime/redimensiona la imagen HASTA que su tamaÃ±o sea <= MAX_FILE_SIZE (1MB).
 * Realiza varias "pasadas" reduciendo gradualmente el tamaÃ±o y la compresiÃ³n. 
 * Retorna el nuevo URI local de la imagen final bajo 1MB (o lo que defina MAX_FILE_SIZE).
 */
async function ensureUnderMaxSize(
  uri: string,
  originalWidth: number,
  originalHeight: number
): Promise<string> {
  let currentUri = uri;
  let width = originalWidth;
  let height = originalHeight;

  // Hasta 3 intentos para ir reduciendo
  const maxPasses = 3;
  // Empieza con una compresiÃ³n razonable
  let compressQuality = 0.7;

  for (let attempt = 1; attempt <= maxPasses; attempt++) {
    const fileInfo = await FileSystem.getInfoAsync(currentUri);
    if (!fileInfo.exists || typeof fileInfo.size !== 'number') {
      // Si algo falla, salimos sin forzar
      return currentUri;
    }
    if (fileInfo.size <= MAX_FILE_SIZE) {
      // Ya estamos por debajo (o igual) al lÃ­mite de 1MB
      return currentUri;
    }
    // Reducir dimensiones de forma aproximada para acercarnos a 1MB
    const ratio = Math.sqrt(MAX_FILE_SIZE / fileInfo.size);
    // Si ratio >= 1, significa que ya estamos "casi" sin necesidad de redimensionar
    // pero igual se comprime un poco mÃ¡s.
    const newWidth = Math.floor(width * Math.min(ratio, 0.9));
    const newHeight = Math.floor(height * Math.min(ratio, 0.9));

    // Procesar con ImageManipulator
    const manipResult = await ImageManipulator.manipulateAsync(
      currentUri,
      [{ resize: { width: newWidth, height: newHeight } }],
      {
        compress: compressQuality,
        format: ImageManipulator.SaveFormat.JPEG,
      }
    );

    currentUri = manipResult.uri;
    width = newWidth;
    height = newHeight;

    // Cada pasada bajamos mÃ¡s la compresiÃ³n
    compressQuality -= 0.1;
    if (compressQuality < 0.3) {
      compressQuality = 0.3;
    }
  }

  // DespuÃ©s de los intentos, devolvemos el resultado (aunque quizÃ¡s siga arriba de 1MB si la imagen era enorme)
  return currentUri;
}

/**
 * El flujo completo de:
 *  1. Elegir la imagen (cÃ¡mara/galerÃ­a)
 *  2. Asegurar que quede por debajo de 1MB (ensureUnderMaxSize)
 *  3. Retornar el URI local final de la imagen procesada
 */
export async function pickAndProcessImage(fromCamera: boolean): Promise<string | null> {
  const result = await pickImageFromSource(fromCamera);
  // Verificamos si el usuario cancelÃ³
  if (!result || result.canceled === true || (result as any).cancelled === true) {
    return null;
  }
  // En SDKs modernos, result.assets es un array con los datos de la imagen
  const asset = result.assets ? result.assets[0] : result;
  if (!asset || !asset.uri) {
    return null;
  }
  // Llamamos a ensureUnderMaxSize para que el archivo no supere 1MB
  const finalUri = await ensureUnderMaxSize(asset.uri, asset.width, asset.height);
  return finalUri;
}

/**
 * Sube la imagen (finalUri) al servidor con multipart/form-data
 * y retorna el file_id devuelto por la API.
 */
export async function uploadImage(localUri: string, token: string): Promise<number | null> {
  try {
    let filename = localUri.split('/').pop() || 'photo.jpg';
    if (!/\.\w+$/.test(filename)) {
      filename = `${filename}.jpg`;
    }
    const match = /\.(\w+)$/.exec(filename);
    // Forzamos 'jpeg' si la extensiÃ³n es '.jpg'
    const type = match
      ? `image/${match[1].toLowerCase() === 'jpg' ? 'jpeg' : match[1].toLowerCase()}`
      : 'image/jpeg';

    const formData = new FormData();
    formData.append('file', {
      uri: localUri,
      name: filename,
      type,
    } as any);

    const uploadResponse = await fetch(`${BASE_URL}/upload`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
      },
      body: formData,
    });

    if (!uploadResponse.ok) {
      Alert.alert('Error', 'Error al subir archivo');
      return null;
    }

    const data = await uploadResponse.json();
    const fileId = data?.file?.id;
    return fileId || null;
  } catch (error: any) {
    Alert.alert('Error', error.message);
    return null;
  }
}

---
